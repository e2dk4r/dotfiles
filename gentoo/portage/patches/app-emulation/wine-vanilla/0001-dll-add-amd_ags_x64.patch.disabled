From afffe9c175ff8ac4d0a3c40b508b333a69e3c26a Mon Sep 17 00:00:00 2001
From: e2dk4r <43293320+e2dk4r@users.noreply.github.com>
Date: Sun, 28 Jan 2024 10:23:36 +0300
Subject: [PATCH] dll: add amd_ags_x64

---
 configure                            |    7 +
 configure.ac                         |   11 +
 dlls/amd_ags_x64/Makefile.in         |   16 +
 dlls/amd_ags_x64/amd_ags.h           | 1895 ++++++++++++++++++++++++++
 dlls/amd_ags_x64/amd_ags_x64.spec    |   45 +
 dlls/amd_ags_x64/amd_ags_x64_main.c  | 1424 +++++++++++++++++++
 dlls/amd_ags_x64/dxvk_interfaces.idl |  151 ++
 dlls/amd_ags_x64/unixlib.c           |  277 ++++
 dlls/amd_ags_x64/unixlib.h           |   42 +
 9 files changed, 3868 insertions(+)
 create mode 100644 dlls/amd_ags_x64/Makefile.in
 create mode 100644 dlls/amd_ags_x64/amd_ags.h
 create mode 100644 dlls/amd_ags_x64/amd_ags_x64.spec
 create mode 100644 dlls/amd_ags_x64/amd_ags_x64_main.c
 create mode 100644 dlls/amd_ags_x64/dxvk_interfaces.idl
 create mode 100644 dlls/amd_ags_x64/unixlib.c
 create mode 100644 dlls/amd_ags_x64/unixlib.h

diff --git a/configure b/configure
index ae5def6..d272b07 100755
--- a/configure
+++ b/configure
@@ -984,6 +984,7 @@ enable_adsldpc
 enable_advapi32
 enable_advpack
 enable_amsi
+enable_amd_ags_x64
 enable_amstream
 enable_apisetschema
 enable_apphelp
@@ -15891,6 +15892,11 @@ enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 fi
 
+
+DRM_CFLAGS=`$PKG_CONFIG --cflags libdrm 2>conftest.err`
+DRM_LIBS=`$PKG_CONFIG --libs libdrm 2>conftest.err`
+DRMAMDGPU_LIBS=`$PKG_CONFIG --libs libdrm_amdgpu 2>conftest.err`
+
 if test "x$with_wayland" != "xno"
 then
     rm -f conftest.err
@@ -21591,6 +21597,7 @@ wine_fn_config_makefile dlls/advapi32/tests enable_tests
 wine_fn_config_makefile dlls/advpack enable_advpack
 wine_fn_config_makefile dlls/advpack/tests enable_tests
 wine_fn_config_makefile dlls/amsi enable_amsi
+wine_fn_config_makefile dlls/amd_ags_x64 enable_amd_ags_x64
 wine_fn_config_makefile dlls/amstream enable_amstream
 wine_fn_config_makefile dlls/amstream/tests enable_tests
 wine_fn_config_makefile dlls/apisetschema enable_apisetschema
diff --git a/configure.ac b/configure.ac
index 475743b..e19f1ff 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1478,6 +1478,16 @@ fi
 WINE_WARNING_WITH(gnutls,[test "x$ac_cv_lib_soname_gnutls" = "x"],
                  [libgnutls ${notice_platform}development files not found, no schannel support.])
 
+
+dnl **** Check for libdrm ****
+WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
+    [AC_CHECK_HEADERS([xf86drm.h],
+        [WINE_CHECK_SONAME(drm,drmOpen,,,[$DRM_LIBS])])])
+
+WINE_PACKAGE_FLAGS(DRMAMDGPU,[libdrm_amdgpu],,,,
+    [AC_CHECK_HEADERS([amdgpu_drm.h],
+        [WINE_CHECK_SONAME(drm_amdgpu,amdgpu_query_info,,,[$DRMAMDGPU_LIBS])])])
+
 dnl **** Check for SANE ****
 if test "x$with_sane" != "xno"
 then
@@ -2408,6 +2418,7 @@ WINE_CONFIG_MAKEFILE(dlls/advapi32/tests)
 WINE_CONFIG_MAKEFILE(dlls/advpack)
 WINE_CONFIG_MAKEFILE(dlls/advpack/tests)
 WINE_CONFIG_MAKEFILE(dlls/amsi)
+WINE_CONFIG_MAKEFILE(dlls/amd_ags_x64)
 WINE_CONFIG_MAKEFILE(dlls/amstream)
 WINE_CONFIG_MAKEFILE(dlls/amstream/tests)
 WINE_CONFIG_MAKEFILE(dlls/apisetschema)
diff --git a/dlls/amd_ags_x64/Makefile.in b/dlls/amd_ags_x64/Makefile.in
new file mode 100644
index 0000000..e167498
--- /dev/null
+++ b/dlls/amd_ags_x64/Makefile.in
@@ -0,0 +1,16 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
+MODULE    = amd_ags_x64.dll
+UNIXLIB   = amd_ags_x64.so
+UNIX_CFLAGS = $(DRM_CFLAGS)
+UNIX_LIBS = $(DRM_LIBS) $(DRMAMDGPU_LIBS)
+IMPORTS   = version vulkan-1 user32
+IMPORTLIB = amd_ags_x64
+
+EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
+
+C_SRCS = \
+	amd_ags_x64_main.c \
+	unixlib.c
+
+IDL_SRCS = \
+	dxvk_interfaces.idl
diff --git a/dlls/amd_ags_x64/amd_ags.h b/dlls/amd_ags_x64/amd_ags.h
new file mode 100644
index 0000000..aac9fb1
--- /dev/null
+++ b/dlls/amd_ags_x64/amd_ags.h
@@ -0,0 +1,1895 @@
+//
+// Copyright (c) 2020 Advanced Micro Devices, Inc. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+//
+
+/// \file
+/// \mainpage
+/// AGS Library Overview
+/// --------------------
+/// This document provides an overview of the AGS (AMD GPU Services) library. The AGS library provides software developers with the ability to query 
+/// AMD GPU software and hardware state information that is not normally available through standard operating systems or graphic APIs.
+///
+/// The latest version of the API is publicly hosted here: https://github.com/GPUOpen-LibrariesAndSDKs/AGS_SDK/.
+/// It is also worth checking http://gpuopen.com/gaming-product/amd-gpu-services-ags-library/ for any updates and articles on AGS.
+/// \internal
+/// Online documentation is publicly hosted here: http://gpuopen-librariesandsdks.github.io/ags/
+/// \endinternal
+///
+/// ---------------------------------------
+/// What's new in AGS 6.0 since version 5.4.2
+/// ---------------------------------------
+/// AGS 6.0 includes the following updates:
+/// * DX12 ray tracing hit token for RDNA2 hardware.
+/// * Shader intrinsic that exposes ReadLaneAt in DX12.
+/// * Shader intrinsics that expose explicit float conversions in DX12.
+/// * Refactored and revised API to minimize user error.
+/// * Added agsGetVersionNumber.
+/// * Detection for external GPUs.
+/// * Detection of RDNA2 architecture.
+/// * Grouped the more established intrinsics together into per year support.
+/// * Function pointer typedefs for the API
+///
+/// ---------------------------------------
+/// What's new in AGS 5.4.2 since version 5.4.1
+/// ---------------------------------------
+/// AGS 5.4.2 includes the following updates:
+/// * sharedMemoryInBytes has been reinstated.
+/// * Clock speed returned for APUs.
+///
+/// ---------------------------------------
+/// What's new in AGS 5.4.1 since version 5.4.0
+/// ---------------------------------------
+/// AGS 5.4.1 includes the following updates:
+/// * AsicFamily_Count to help with code maintenance.
+/// * Visual Studio 2019 support.
+/// * x86 support
+/// * BaseInstance and BaseVertex intrinsics along with corresponding caps bits.
+/// * GetWaveSize intrinsic along with corresponding caps bits.
+///
+/// ---------------------------------------
+/// What's new in AGS 5.4 since version 5.3
+/// ---------------------------------------
+/// AGS 5.4 includes the following updates:
+/// * A more detailed description of the GPU architecture, now including RDNA GPUs.
+/// * Radeon 7 core and memory speeds returned.
+/// * Draw index and Atomic U64 intrinsics for both DX11 and DX12.
+///
+/// ---------------------------------------
+/// What's new in AGS 5.3 since version 5.2
+/// ---------------------------------------
+/// AGS 5.3 includes the following updates:
+/// * DX11 deferred context support for Multi Draw Indirect and UAV Overlap extensions.
+/// * A Radeon Software Version helper to determine whether the installed driver meets your game's minimum driver version requirements.
+/// * Freesync HDR Gamma 2.2 mode which uses a 1010102 swapchain and can be considered as an alternative to using the 64 bit swapchain required for Freesync HDR scRGB.
+///
+/// What's new in AGS 5.2.1 since version 5.2.0
+/// ---------------------------------------
+/// * Fix for crash when using Eyefinity
+/// * Fix for DX12 app registration in the UWP version
+///
+///
+/// What's new in AGS 5.2.0 since version 5.1
+/// ---------------------------------------
+/// AGS 5.2 includes the following updates:
+/// * DX12 app registration API
+/// * DX11 breadcrumb marker API for tracking down GPU hangs:\ref agsDriverExtensionsDX11_WriteBreadcrumb
+/// * DX12 extensions now require the creation of the device via \ref agsDriverExtensionsDX12_CreateDevice
+/// * agsGetCrossfireGPUCount has been removed in favor of retrieving the value from \ref agsDriverExtensionsDX11_CreateDevice
+/// * API change that fixes a reference leak in \ref agsDriverExtensionsDX11_DestroyDevice
+///
+/// What's new in AGS 5.1.1 since version 5.0.6
+/// ---------------------------------------
+/// AGS 5.1.1 includes the following updates:
+/// * An API change for DX11 extensions
+///   - It is now mandatory to call agsDriverExtensionsDX11_CreateDevice() when creating a device if the user wants to access any DX11 AMD extensions.
+///   - The corresponding agsDriverExtensionsDX11_DestroyDevice() call must be called to release the device and free up the internal resources allocated by the create call.
+/// * App registration extension for DX11.
+/// * Freesync 2 HDR support.
+/// * Wave reduce and wave scan shader extensions.
+/// * AMD user markers for DX12.
+/// * Eyefinity bug fixes.
+/// * MultiDrawIndexedInstancedIndirectCountIndirect parameter bug fix.
+/// * Static lib versions of the binary.
+/// * VS2017 support for the samples.
+///
+/// What's new in AGS 5.x since version 4.x
+/// ---------------------------------------
+/// Version 5.x is a major overhaul of the library designed to provide a much clearer view of the GPUs in the system and the displays attached to them. 
+/// It also exposes the ability to query each display for HDR capabilities and put those HDR capable displays into various HDR modes.
+/// Some functions such as agsGetGPUMemorySize and agsGetEyefinityConfigInfo have been removed in favor of including this information in the device & display enumeration.
+/// Features include:
+/// * Full GPU enumeration with adapter string, device id, revision id and vendor id.
+/// * Per GPU display enumeration including information on display name, resolution and HDR capabilities.
+/// * Optional user supplied memory allocator.
+/// * Function to set displays into HDR mode.
+/// * A Microsoft WACK compliant version of the library.
+/// * DirectX11 shader compiler controls.
+/// * DirectX11 multiview extension enabling MultiView and MultiRes rendering.
+/// * DirectX11 Crossfire API now supports using the API without needing a driver profile. Can also specify the transfer engine.
+///
+/// Using the AGS library
+/// ---------------------
+/// It is recommended to take a look at the source code for the samples that come with the AGS SDK:
+/// * AGSSample
+/// * CrossfireSample
+/// * EyefinitySample
+/// The AGSSample application is the simplest of the three examples and demonstrates the code required to initialize AGS and use it to query the GPU and Eyefinity state. 
+/// The CrossfireSample application demonstrates the use of the new API to transfer resources on GPUs in Crossfire mode. Lastly, the EyefinitySample application provides a more 
+/// extensive example of Eyefinity setup than the basic example provided in AGSSample.
+/// There are other samples on Github that demonstrate the DirectX shader extensions, such as the Barycentrics11 and Barycentrics12 samples.
+///
+/// To add AGS support to an existing project, follow these steps:
+/// * Link your project against the correct import library. Choose from either the 32 bit or 64 bit version.
+/// * Copy the AGS dll into the same directory as your game executable.
+/// * Include the amd_ags.h header file from your source code.
+/// * Include the AGS hlsl files if you are using the shader intrinsics.
+/// * Declare a pointer to an AGSContext and make this available for all subsequent calls to AGS.
+/// * On game initialization, call \ref agsInitialize passing in the address of the context. On success, this function will return a valid context pointer.
+///
+/// Don't forget to cleanup AGS by calling \ref agsDeInitialize when the app exits, after the device has been destroyed.
+
+#ifndef AMD_AGS_H
+#define AMD_AGS_H
+
+#define AMD_AGS_VERSION_MAJOR 6             ///< AGS major version
+#define AMD_AGS_VERSION_MINOR 0             ///< AGS minor version
+#define AMD_AGS_VERSION_PATCH 1             ///< AGS patch version
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/// \defgroup Defines AGS defines
+/// @{
+#define AMD_AGS_API WINAPI
+
+#define AGS_MAKE_VERSION( major, minor, patch ) ( ( major << 22 ) | ( minor << 12 ) | patch ) ///< Macro to create the app and engine versions for the fields in \ref AGSDX12ExtensionParams and \ref AGSDX11ExtensionParams and the Radeon Software Version
+#define AGS_UNSPECIFIED_VERSION 0xFFFFAD00                                                    ///< Use this to specify no version
+/// @}
+
+// Forward declaration of D3D and DXGI types
+struct IDXGIAdapter;
+struct IDXGISwapChain;
+struct DXGI_SWAP_CHAIN_DESC;
+enum D3D_DRIVER_TYPE;
+enum D3D_FEATURE_LEVEL;
+ enum D3D_PRIMITIVE_TOPOLOGY;
+
+// Forward declaration of D3D11 types
+struct ID3D11Device;
+struct ID3D11DeviceContext;
+struct ID3D11Resource;
+struct ID3D11Buffer;
+struct ID3D11Texture1D;
+struct ID3D11Texture2D;
+struct ID3D11Texture3D;
+struct D3D11_BUFFER_DESC;
+struct D3D11_TEXTURE1D_DESC;
+struct D3D11_TEXTURE2D_DESC;
+struct D3D11_TEXTURE3D_DESC;
+struct D3D11_SUBRESOURCE_DATA;
+
+// Forward declaration of D3D12 types
+struct ID3D12Device;
+struct ID3D12GraphicsCommandList;
+
+/// \defgroup enums General enumerations
+/// @{
+
+/// The return codes
+typedef enum AGSReturnCode
+{
+    AGS_SUCCESS,                    ///< Successful function call
+    AGS_FAILURE,                    ///< Failed to complete call for some unspecified reason
+    AGS_INVALID_ARGS,               ///< Invalid arguments into the function
+    AGS_OUT_OF_MEMORY,              ///< Out of memory when allocating space internally
+    AGS_MISSING_D3D_DLL,            ///< Returned when a D3D dll fails to load
+    AGS_LEGACY_DRIVER,              ///< Returned if a feature is not present in the installed driver
+    // AGS_NO_AMD_DRIVER_INSTALLED ADDED IN 5.4.1
+    AGS_NO_AMD_DRIVER_INSTALLED,    ///< Returned if the AMD GPU driver does not appear to be installed
+    AGS_EXTENSION_NOT_SUPPORTED,    ///< Returned if the driver does not support the requested driver extension
+    AGS_ADL_FAILURE,                ///< Failure in ADL (the AMD Display Library)
+    AGS_DX_FAILURE,                  ///< Failure from DirectX runtime
+    AGS_D3DDEVICE_NOT_CREATED,      ///< Failure due to not creating the D3D device successfully via AGS.
+} AGSReturnCode;
+
+/// The DirectX11 extension support bits
+typedef enum AGSDriverExtensionDX11
+{
+    AGS_DX11_EXTENSION_QUADLIST                             = 1 << 0,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_SCREENRECTLIST                       = 1 << 1,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_UAV_OVERLAP                          = 1 << 2,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_DEPTH_BOUNDS_TEST                    = 1 << 3,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_MULTIDRAWINDIRECT                    = 1 << 4,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_MULTIDRAWINDIRECT_COUNTINDIRECT      = 1 << 5,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_CROSSFIRE_API                        = 1 << 6,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 7,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_READLANE                   = 1 << 8,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_LANEID                     = 1 << 9,    ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_SWIZZLE                    = 1 << 10,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BALLOT                     = 1 << 11,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_MBCOUNT                    = 1 << 12,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_MED3                       = 1 << 13,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BARYCENTRICS               = 1 << 14,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_WAVE_REDUCE                = 1 << 15,   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_WAVE_SCAN                  = 1 << 16,   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX11_EXTENSION_CREATE_SHADER_CONTROLS               = 1 << 17,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX11_EXTENSION_MULTIVIEW                            = 1 << 18,   ///< Supported in Radeon Software Version 16.12.1 onwards.
+    AGS_DX11_EXTENSION_APP_REGISTRATION                     = 1 << 19,   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX11_EXTENSION_BREADCRUMB_MARKERS                   = 1 << 20,   ///< Supported in Radeon Software Version 17.11.1 onwards.
+    AGS_DX11_EXTENSION_MDI_DEFERRED_CONTEXTS                = 1 << 21,   ///< Supported in Radeon Software Version 18.8.1 onwards.
+    AGS_DX11_EXTENSION_UAV_OVERLAP_DEFERRED_CONTEXTS        = 1 << 22,   ///< Supported in Radeon Software Version 18.8.1 onwards.
+    AGS_DX11_EXTENSION_DEPTH_BOUNDS_DEFERRED_CONTEXTS       = 1 << 23,   ///< Supported in Radeon Software Version 18.8.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_DRAW_INDEX                 = 1 << 24,   ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 25,   ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_GET_WAVE_SIZE              = 1 << 26,   ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BASE_VERTEX                = 1 << 27,   ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX11_EXTENSION_INTRINSIC_BASE_INSTANCE              = 1 << 28    ///< Supported in Radeon Software Version 20.2.1 onwards.
+} AGSDriverExtensionDX11;
+
+/// The DirectX12 extension support bits
+typedef enum AGSDriverExtensionDX12
+{
+    AGS_DX12_EXTENSION_INTRINSIC_READFIRSTLANE              = 1 << 0,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_READLANE                   = 1 << 1,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_LANEID                     = 1 << 2,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_SWIZZLE                    = 1 << 3,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BALLOT                     = 1 << 4,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_MBCOUNT                    = 1 << 5,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_MED3                       = 1 << 6,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BARYCENTRICS               = 1 << 7,   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_WAVE_REDUCE                = 1 << 8,   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_WAVE_SCAN                  = 1 << 9,   ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_USER_MARKERS                         = 1 << 10,  ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_APP_REGISTRATION                     = 1 << 11,  ///< Supported in Radeon Software Version 17.9.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_UAV_BIND_SLOT              = 1 << 12,  ///< Supported in Radeon Software Version 19.5.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_DRAW_INDEX                 = 1 << 13,  ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_ATOMIC_U64                 = 1 << 14,  ///< Supported in Radeon Software Version 19.12.2 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BASE_VERTEX                = 1 << 15,  ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_BASE_INSTANCE              = 1 << 16,  ///< Supported in Radeon Software Version 20.2.1 onwards.
+    AGS_DX12_EXTENSION_INTRINSIC_GET_WAVE_SIZE              = 1 << 17   ///< Supported in Radeon Software Version 20.5.1 onwards.
+} AGSDriverExtensionDX12;
+
+/// The space id for DirectX12 intrinsic support
+const unsigned int AGS_DX12_SHADER_INTRINSICS_SPACE_ID = 0x7FFF0ADE; // 2147420894
+
+/// The display flags describing various properties of the display.
+typedef enum AGSDisplayFlags
+{
+    AGS_DISPLAYFLAG_PRIMARY_DISPLAY                         = 1 << 0,   ///< Whether this display is marked as the primary display. Not set on the WACK version.
+    AGS_DISPLAYFLAG_HDR10                                   = 1 << 1,   ///< HDR10 is supported on this display
+    AGS_DISPLAYFLAG_DOLBYVISION                             = 1 << 2,   ///< Dolby Vision is supported on this display
+    AGS_DISPLAYFLAG_FREESYNC                                = 1 << 3,   ///< Freesync is supported on this display
+    AGS_DISPLAYFLAG_FREESYNC_HDR                            = 1 << 4,   ///< Freesync HDR is supported on this display
+    AGS_DISPLAYFLAG_EYEFINITY_IN_GROUP                      = 1 << 5,   ///< The display is part of the Eyefinity group
+    AGS_DISPLAYFLAG_EYEFINITY_PREFERRED_DISPLAY             = 1 << 6,   ///< The display is the preferred display in the Eyefinity group for displaying the UI
+    AGS_DISPLAYFLAG_EYEFINITY_IN_PORTRAIT_MODE              = 1 << 7,   ///< The display is in the Eyefinity group but in portrait mode
+} AGSDisplayFlags;
+
+/// The display settings flags.
+typedef enum AGSDisplaySettingsFlags
+{
+    AGS_DISPLAYSETTINGSFLAG_DISABLE_LOCAL_DIMMING           = 1 << 0,   ///< Disables local dimming if possible
+} AGSDisplaySettingsFlags;
+
+/// @}
+
+typedef struct AGSContext AGSContext;  ///< All function calls in AGS require a pointer to a context. This is generated via \ref agsInitialize
+
+/// The rectangle struct used by AGS.
+typedef struct AGSRect
+{
+    int offsetX;    ///< Offset on X axis
+    int offsetY;    ///< Offset on Y axis
+    int width;      ///< Width of rectangle
+    int height;     ///< Height of rectangle
+} AGSRect;
+
+/// The display info struct used to describe a display enumerated by AGS
+typedef struct AGSDisplayInfo_511
+{
+    char                    name[ 256 ];                    ///< The name of the display
+    char                    displayDeviceName[ 32 ];        ///< The display device name, i.e. DISPLAY_DEVICE::DeviceName
+
+    unsigned int            displayFlags;                   ///< Bitfield of \ref AGSDisplayFlags
+
+    int                     maxResolutionX;                 ///< The maximum supported resolution of the unrotated display
+    int                     maxResolutionY;                 ///< The maximum supported resolution of the unrotated display
+    float                   maxRefreshRate;                 ///< The maximum supported refresh rate of the display
+
+    AGSRect                 currentResolution;              ///< The current resolution and position in the desktop, ignoring Eyefinity bezel compensation
+    AGSRect                 visibleResolution;              ///< The visible resolution and position. When Eyefinity bezel compensation is enabled this will
+                                                            ///< be the sub region in the Eyefinity single large surface (SLS)
+    float                   currentRefreshRate;             ///< The current refresh rate
+
+    int                     eyefinityGridCoordX;            ///< The X coordinate in the Eyefinity grid. -1 if not in an Eyefinity group
+    int                     eyefinityGridCoordY;            ///< The Y coordinate in the Eyefinity grid. -1 if not in an Eyefinity group
+
+    double                  chromaticityRedX;               ///< Red display primary X coord
+    double                  chromaticityRedY;               ///< Red display primary Y coord
+
+    double                  chromaticityGreenX;             ///< Green display primary X coord
+    double                  chromaticityGreenY;             ///< Green display primary Y coord
+
+    double                  chromaticityBlueX;              ///< Blue display primary X coord
+    double                  chromaticityBlueY;              ///< Blue display primary Y coord
+
+    double                  chromaticityWhitePointX;        ///< White point X coord
+    double                  chromaticityWhitePointY;        ///< White point Y coord
+
+    double                  screenDiffuseReflectance;       ///< Percentage expressed between 0 - 1
+    double                  screenSpecularReflectance;      ///< Percentage expressed between 0 - 1
+
+    double                  minLuminance;                   ///< The minimum luminance of the display in nits
+    double                  maxLuminance;                   ///< The maximum luminance of the display in nits
+    double                  avgLuminance;                   ///< The average luminance of the display in nits
+
+    int                     logicalDisplayIndex;            ///< The internally used index of this display
+    int                     adlAdapterIndex;                ///< The internally used ADL adapter index
+} AGSDisplayInfo_511;
+
+/// The display info struct used to describe a display enumerated by AGS
+typedef struct AGSDisplayInfo_600
+{
+    char                    name[ 256 ];                    ///< The name of the display
+    char                    displayDeviceName[ 32 ];        ///< The display device name, i.e. DISPLAY_DEVICE::DeviceName
+
+    unsigned int            isPrimaryDisplay : 1;           ///< Whether this display is marked as the primary display
+    unsigned int            HDR10 : 1;                      ///< HDR10 is supported on this display
+    unsigned int            dolbyVision : 1;                ///< Dolby Vision is supported on this display
+    unsigned int            freesync : 1;                   ///< Freesync is supported on this display
+    unsigned int            freesyncHDR : 1;                ///< Freesync HDR is supported on this display
+    unsigned int            eyefinityInGroup : 1;           ///< The display is part of the Eyefinity group
+    unsigned int            eyefinityPreferredDisplay : 1;  ///< The display is the preferred display in the Eyefinity group for displaying the UI
+    unsigned int            eyefinityInPortraitMode : 1;    ///< The display is in the Eyefinity group but in portrait mode
+    unsigned int            reservedPadding : 24;           ///< Reserved for future use
+
+    int                     maxResolutionX;                 ///< The maximum supported resolution of the unrotated display
+    int                     maxResolutionY;                 ///< The maximum supported resolution of the unrotated display
+    float                   maxRefreshRate;                 ///< The maximum supported refresh rate of the display
+
+    AGSRect                 currentResolution;              ///< The current resolution and position in the desktop, ignoring Eyefinity bezel compensation
+    AGSRect                 visibleResolution;              ///< The visible resolution and position. When Eyefinity bezel compensation is enabled this will
+                                                            ///< be the sub region in the Eyefinity single large surface (SLS)
+    float                   currentRefreshRate;             ///< The current refresh rate
+
+    int                     eyefinityGridCoordX;            ///< The X coordinate in the Eyefinity grid. -1 if not in an Eyefinity group
+    int                     eyefinityGridCoordY;            ///< The Y coordinate in the Eyefinity grid. -1 if not in an Eyefinity group
+
+    double                  chromaticityRedX;               ///< Red display primary X coord
+    double                  chromaticityRedY;               ///< Red display primary Y coord
+
+    double                  chromaticityGreenX;             ///< Green display primary X coord
+    double                  chromaticityGreenY;             ///< Green display primary Y coord
+
+    double                  chromaticityBlueX;              ///< Blue display primary X coord
+    double                  chromaticityBlueY;              ///< Blue display primary Y coord
+
+    double                  chromaticityWhitePointX;        ///< White point X coord
+    double                  chromaticityWhitePointY;        ///< White point Y coord
+
+    double                  screenDiffuseReflectance;       ///< Percentage expressed between 0 - 1
+    double                  screenSpecularReflectance;      ///< Percentage expressed between 0 - 1
+
+    double                  minLuminance;                   ///< The minimum luminance of the display in nits
+    double                  maxLuminance;                   ///< The maximum luminance of the display in nits
+    double                  avgLuminance;                   ///< The average luminance of the display in nits
+
+    int                     logicalDisplayIndex;            ///< The internally used index of this display
+    int                     adlAdapterIndex;                ///< The internally used ADL adapter index
+    int                     reserved;                       ///< reserved field
+} AGSDisplayInfo_600;
+
+/// The architecture version
+typedef enum ArchitectureVersion
+{
+    ArchitectureVersion_Unknown,                                ///< Unknown architecture, potentially from another IHV. Check \ref AGSDeviceInfo::vendorId
+    ArchitectureVersion_PreGCN,                                 ///< AMD architecture, pre-GCN
+    ArchitectureVersion_GCN                                     ///< AMD GCN architecture
+} ArchitectureVersion;
+
+/// The ASIC family
+typedef enum AsicFamily
+{
+    AsicFamily_Unknown,                                         ///< Unknown architecture, potentially from another IHV. Check \ref AGSDeviceInfo::vendorId
+    AsicFamily_PreGCN,                                          ///< Pre GCN architecture.
+    AsicFamily_GCN1,                                            ///< AMD GCN 1 architecture: Oland, Cape Verde, Pitcairn & Tahiti.
+    AsicFamily_GCN2,                                            ///< AMD GCN 2 architecture: Hawaii & Bonaire.  This also includes APUs Kaveri and Carrizo.
+    AsicFamily_GCN3,                                            ///< AMD GCN 3 architecture: Tonga & Fiji.
+    AsicFamily_GCN4,                                            ///< AMD GCN 4 architecture: Polaris.
+    AsicFamily_Vega,                                            ///< AMD Vega architecture, including Raven Ridge (ie AMD Ryzen CPU + AMD Vega GPU).
+    AsicFamily_RDNA,                                            ///< AMD RDNA architecture
+    AsicFamily_RDNA2,                                           ///< AMD RDNA2 architecture
+    AsicFamily_RDNA3,                                           ///< AMD RDNA3 architecture
+
+    AsicFamily_Count                                            ///< Number of enumerated ASIC families
+} AsicFamily;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_511
+{
+    ArchitectureVersion             architectureVersion;            ///< Set to Unknown if not AMD hardware
+    const char*                     adapterString;                  ///< The adapter name string
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of GCN compute units. Zero if not GCN
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    long long                       localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo_511*             displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_511;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_520
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    ArchitectureVersion             architectureVersion;            ///< Set to Unknown if not AMD hardware
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units. Zero if not GCN onwards
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    long long                       localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo_511*             displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_520;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_540
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    AsicFamily                      asicFamily;                     ///< Set to Unknown if not AMD hardware
+    int                             isAPU;                          ///< Whether or not this is an APU
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units.
+    int                             numWGPs;                        ///< Number of RDNA Work Group Processors.  Only valid if ASIC is RDNA onwards.
+
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    unsigned long long              localMemoryInBytes;             ///< The size of local memory in bytes.
+    unsigned long long              sharedMemoryInBytes;            ///< The size of system memory available to the GPU in bytes.  It is important to factor this into your VRAM budget for APUs
+                                                                    ///< as the reported local memory will only be a small fraction of the total memory available to the GPU.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo_511*             displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_540;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_541
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    AsicFamily                      asicFamily;                     ///< Set to Unknown if not AMD hardware
+    int                             isAPU;                          ///< Whether or not this is an APU
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units.
+    int                             numWGPs;                        ///< Number of RDNA Work Group Processors.  Only valid if ASIC is RDNA onwards.
+
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    long long                       localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo_511*             displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_541;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_542
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    AsicFamily                      asicFamily;                     ///< Set to Unknown if not AMD hardware
+    int                             isAPU;                          ///< Whether or not this is an APU
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units.
+    int                             numWGPs;                        ///< Number of RDNA Work Group Processors.  Only valid if ASIC is RDNA onwards.
+
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    int                             isPrimaryDevice;                ///< Whether or not this is the primary adapter in the system. Not set on the WACK version.
+    unsigned long long              localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+    unsigned long long              sharedMemoryInBytes;            ///< The size of system memory available to the GPU in bytes.  It is important to factor this into your VRAM budget for APUs
+                                                                    ///< as the reported local memory will only be a small fraction of the total memory available to the GPU.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo_511*             displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+} AGSDeviceInfo_542;
+
+/// The device info struct used to describe a physical GPU enumerated by AGS
+typedef struct AGSDeviceInfo_600
+{
+    const char*                     adapterString;                  ///< The adapter name string
+    AsicFamily                      asicFamily;                     ///< Set to Unknown if not AMD hardware
+    unsigned int                    isAPU : 1;                      ///< Whether this device is an APU
+    unsigned int                    isPrimaryDevice : 1;            ///< Whether this device is marked as the primary device
+    unsigned int                    isExternal :1;                  ///< Whether this device is a detachable, external device
+    unsigned int                    reservedPadding : 29;           ///< Reserved for future use
+
+    int                             vendorId;                       ///< The vendor id
+    int                             deviceId;                       ///< The device id
+    int                             revisionId;                     ///< The revision id
+
+    int                             numCUs;                         ///< Number of compute units
+    int                             numWGPs;                        ///< Number of RDNA Work Group Processors.  Only valid if ASIC is RDNA onwards.
+
+    int                             numROPs;                        ///< Number of ROPs
+    int                             coreClock;                      ///< Core clock speed at 100% power in MHz
+    int                             memoryClock;                    ///< Memory clock speed at 100% power in MHz
+    int                             memoryBandwidth;                ///< Memory bandwidth in MB/s
+    float                           teraFlops;                      ///< Teraflops of GPU. Zero if not GCN onwards. Calculated from iCoreClock * iNumCUs * 64 Pixels/clk * 2 instructions/MAD
+
+    unsigned long long              localMemoryInBytes;             ///< The size of local memory in bytes. 0 for non AMD hardware.
+    unsigned long long              sharedMemoryInBytes;            ///< The size of system memory available to the GPU in bytes.  It is important to factor this into your VRAM budget for APUs
+                                                                    ///< as the reported local memory will only be a small fraction of the total memory available to the GPU.
+
+    int                             numDisplays;                    ///< The number of active displays found to be attached to this adapter.
+    AGSDisplayInfo_600*             displays;                       ///< List of displays allocated by AGS to be numDisplays in length.
+
+    int                             eyefinityEnabled;               ///< Indicates if Eyefinity is active
+    int                             eyefinityGridWidth;             ///< Contains width of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityGridHeight;            ///< Contains height of the multi-monitor grid that makes up the Eyefinity Single Large Surface.
+    int                             eyefinityResolutionX;           ///< Contains width in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityResolutionY;           ///< Contains height in pixels of the multi-monitor Single Large Surface.
+    int                             eyefinityBezelCompensated;      ///< Indicates if bezel compensation is used for the current SLS display area. 1 if enabled, and 0 if disabled.
+
+    int                             adlAdapterIndex;                ///< Internally used index into the ADL list of adapters
+    int                             reserved;                       ///< reserved field
+} AGSDeviceInfo_600;
+
+struct AGSDeviceInfo;
+
+/// \defgroup general General API functions
+/// API for initialization, cleanup, HDR display modes and Crossfire GPU count
+/// @{
+
+typedef void* (__stdcall *AGS_ALLOC_CALLBACK_511)( int allocationSize );    ///< AGS user defined allocation prototype
+typedef void* (__stdcall *AGS_ALLOC_CALLBACK)( size_t allocationSize );     ///< AGS user defined allocation prototype
+typedef void (__stdcall *AGS_FREE_CALLBACK)( void* allocationPtr );         ///< AGS user defined free prototype
+
+/// The configuration options that can be passed in to \ref agsInititalize
+typedef struct AGSConfiguration_511
+{
+    AGS_ALLOC_CALLBACK_511  allocCallback;                  ///< Optional memory allocation callback. If not supplied, malloc() is used
+    AGS_FREE_CALLBACK       freeCallback;                   ///< Optional memory freeing callback. If not supplied, free() is used
+} AGSConfiguration_511;
+
+typedef struct AGSConfiguration_520
+{
+    AGS_ALLOC_CALLBACK      allocCallback;                  ///< Optional memory allocation callback. If not supplied, malloc() is used
+    AGS_FREE_CALLBACK       freeCallback;                   ///< Optional memory freeing callback. If not supplied, free() is used
+} AGSConfiguration_520;
+
+typedef union AGSConfiguration
+{
+    AGSConfiguration_511    agsConfiguration511;
+    AGSConfiguration_520    agsConfiguration520;
+} AGSConfiguration;
+
+/// The top level GPU information returned from \ref agsInitialize
+typedef struct AGSGPUInfo_511
+{
+    int                     agsVersionMajor;                ///< Major field of Major.Minor.Patch AGS version number
+    int                     agsVersionMinor;                ///< Minor field of Major.Minor.Patch AGS version number
+    int                     agsVersionPatch;                ///< Patch field of Major.Minor.Patch AGS version number
+    int                     isWACKCompliant;                ///< 1 if WACK compliant.
+
+    const char*             driverVersion;                  ///< The AMD driver package version
+    const char*             radeonSoftwareVersion;          ///< The Radeon Software Version
+
+    int                     numDevices;                     ///< Number of GPUs in the system
+    struct AGSDeviceInfo*   devices;                        ///< List of GPUs in the system
+} AGSGPUInfo_511;
+
+/// The top level GPU information returned from \ref agsInit
+typedef struct AGSGPUInfo_600
+{
+    const char*             driverVersion;                  ///< The AMD driver package version
+    const char*             radeonSoftwareVersion;          ///< The Radeon Software Version
+
+    int                     numDevices;                     ///< Number of GPUs in the system
+    struct AGSDeviceInfo*   devices;                        ///< List of GPUs in the system
+} AGSGPUInfo_600;
+
+/// The display mode
+typedef enum AGSDisplaySettings_Mode_506
+{
+    Mode_506_SDR,                                       ///< SDR mode
+    Mode_506_scRGB,                                     ///< scRGB, requiring an FP16 swapchain. Values of 1.0 == 80 nits, 125.0 == 10000 nits. Uses REC709 primaries.
+    Mode_506_PQ,                                        ///< PQ encoding, requiring a 1010102 UNORM swapchain and PQ encoding in the output shader. Uses BT2020 primaries.
+    Mode_506_DolbyVision                                ///< Dolby Vision, requiring an 8888 UNORM swapchain
+} AGSDisplaySettings_Mode_506;
+
+typedef enum AGSDisplaySettings_Mode_600
+{
+    Mode_600_SDR,                                           ///< SDR mode
+    Mode_600_HDR10_PQ,                                      ///< HDR10 PQ encoding, requiring a 1010102 UNORM swapchain and PQ encoding in the output shader.
+    Mode_600_HDR10_scRGB,                                   ///< HDR10 scRGB, requiring an FP16 swapchain. Values of 1.0 == 80 nits, 125.0 == 10000 nits.
+    Mode_600_FreesyncHDR_scRGB,                             ///< Freesync HDR scRGB, requiring an FP16 swapchain. A value of 1.0 == 80 nits.
+    Mode_600_FreesyncHDR_Gamma22,                           ///< Freesync HDR Gamma 2.2, requiring a 1010102 UNORM swapchain.  The output needs to be encoded to gamma 2.2.
+    Mode_600_DolbyVision,                                   ///< Dolby Vision, requiring an 8888 UNORM swapchain
+
+    Mode_600_Count                                          ///< Number of enumerated display modes
+} AGSDisplaySettings_Mode_600;
+
+/// The struct to specify the display settings to the driver.
+typedef struct AGSDisplaySettings_506
+{
+    AGSDisplaySettings_Mode_506 mode;                           ///< The display mode to set the display into
+
+    double                  chromaticityRedX;               ///< Red display primary X coord
+    double                  chromaticityRedY;               ///< Red display primary Y coord
+
+    double                  chromaticityGreenX;             ///< Green display primary X coord
+    double                  chromaticityGreenY;             ///< Green display primary Y coord
+
+    double                  chromaticityBlueX;              ///< Blue display primary X coord
+    double                  chromaticityBlueY;              ///< Blue display primary Y coord
+
+    double                  chromaticityWhitePointX;        ///< White point X coord
+    double                  chromaticityWhitePointY;        ///< White point Y coord
+
+    double                  minLuminance;                   ///< The minimum scene luminance in nits
+    double                  maxLuminance;                   ///< The maximum scene luminance in nits
+
+    double                  maxContentLightLevel;           ///< The maximum content light level in nits (MaxCLL)
+    double                  maxFrameAverageLightLevel;      ///< The maximum frame average light level in nits (MaxFALL)
+} AGSDisplaySettings_506;
+
+/// The struct to specify the display settings to the driver.
+typedef struct AGSDisplaySettings_511
+{
+    AGSDisplaySettings_Mode_600 mode;                           ///< The display mode to set the display into
+
+    double                  chromaticityRedX;               ///< Red display primary X coord
+    double                  chromaticityRedY;               ///< Red display primary Y coord
+
+    double                  chromaticityGreenX;             ///< Green display primary X coord
+    double                  chromaticityGreenY;             ///< Green display primary Y coord
+
+    double                  chromaticityBlueX;              ///< Blue display primary X coord
+    double                  chromaticityBlueY;              ///< Blue display primary Y coord
+
+    double                  chromaticityWhitePointX;        ///< White point X coord
+    double                  chromaticityWhitePointY;        ///< White point Y coord
+
+    double                  minLuminance;                   ///< The minimum scene luminance in nits
+    double                  maxLuminance;                   ///< The maximum scene luminance in nits
+
+    double                  maxContentLightLevel;           ///< The maximum content light level in nits (MaxCLL)
+    double                  maxFrameAverageLightLevel;      ///< The maximum frame average light level in nits (MaxFALL)
+
+    // ADDED IN 5.2.0
+    int                     flags;                          ///< Bitfield of ::AGSDisplaySettingsFlags
+} AGSDisplaySettings_511;
+
+/// The struct to specify the display settings to the driver.
+typedef struct AGSDisplaySettings_600
+{
+    AGSDisplaySettings_Mode_600 mode;                           ///< The display mode to set the display into
+
+    double                  chromaticityRedX;               ///< Red display primary X coord
+    double                  chromaticityRedY;               ///< Red display primary Y coord
+
+    double                  chromaticityGreenX;             ///< Green display primary X coord
+    double                  chromaticityGreenY;             ///< Green display primary Y coord
+
+    double                  chromaticityBlueX;              ///< Blue display primary X coord
+    double                  chromaticityBlueY;              ///< Blue display primary Y coord
+
+    double                  chromaticityWhitePointX;        ///< White point X coord
+    double                  chromaticityWhitePointY;        ///< White point Y coord
+
+    double                  minLuminance;                   ///< The minimum scene luminance in nits
+    double                  maxLuminance;                   ///< The maximum scene luminance in nits
+
+    double                  maxContentLightLevel;           ///< The maximum content light level in nits (MaxCLL)
+    double                  maxFrameAverageLightLevel;      ///< The maximum frame average light level in nits (MaxFALL)
+
+    unsigned int            disableLocalDimming : 1;        ///< Disables local dimming if possible
+    unsigned int            reservedPadding : 31;           ///< Reserved
+} AGSDisplaySettings_600;
+
+typedef union AGSDisplaySettings
+{
+    AGSDisplaySettings_506 agsDisplaySettings506;
+    AGSDisplaySettings_511 agsDisplaySettings511;
+    AGSDisplaySettings_600 agsDisplaySettings600;
+} AGSDisplaySettings;
+
+/// The result returned from \ref agsCheckDriverVersion
+typedef enum AGSDriverVersionResult
+{
+    AGS_SOFTWAREVERSIONCHECK_OK,                              ///< The reported Radeon Software Version is newer or the same as the required version
+    AGS_SOFTWAREVERSIONCHECK_OLDER,                           ///< The reported Radeon Software Version is older than the required version
+    AGS_SOFTWAREVERSIONCHECK_UNDEFINED                        ///< The check could not determine as result.  This could be because it is a private or custom driver or just invalid arguments.
+} AGSDriverVersionResult;
+
+///
+/// Helper function to check the installed software version against the required software version.
+///
+/// \param [in] radeonSoftwareVersionReported       The Radeon Software Version returned from \ref AGSGPUInfo::radeonSoftwareVersion.
+/// \param [in] radeonSoftwareVersionRequired       The Radeon Software Version to check against.  This is specificed using \ref AGS_MAKE_VERSION.
+/// \return                                         The result of the check.
+///
+AMD_AGS_API AGSDriverVersionResult agsCheckDriverVersion( const char* radeonSoftwareVersionReported, unsigned int radeonSoftwareVersionRequired );
+
+///
+/// Function to return the AGS version number.
+///
+/// \return                                         The version number made using AGS_MAKE_VERSION( AMD_AGS_VERSION_MAJOR, AMD_AGS_VERSION_MINOR, AMD_AGS_VERSION_PATCH ).
+///
+AMD_AGS_API int agsGetVersionNumber( void );
+
+///
+/// Function used to initialize the AGS library.
+/// Must be called prior to any of the subsequent AGS API calls.
+/// Must be called prior to ID3D11Device or ID3D12Device creation.
+/// \note The caller of this function should handle the possibility of the call failing in the cases below. One option is to do a vendor id check and only call \ref agsInit if there is an AMD GPU present.
+/// \note This function will fail with \ref AGS_NO_AMD_DRIVER_INSTALLED if there is no AMD driver found on the system.
+/// \note This function will fail with \ref AGS_LEGACY_DRIVER in Catalyst versions before 12.20.
+/// \note It is good practice to check the AGS version returned from AGSGPUInfo against the version defined in the header in case a mismatch between the dll and header has occurred.
+///
+/// \param [in, out] context                        Address of a pointer to a context. This function allocates a context on the heap which is then required for all subsequent API calls.
+/// \param [in] config                              Optional pointer to a AGSConfiguration struct to override the default library configuration.
+/// \param [out] gpuInfo                            Optional pointer to a AGSGPUInfo struct which will get filled in for all the GPUs in the system.
+///
+AMD_AGS_API AGSReturnCode agsInit( AGSContext** context, const AGSConfiguration* config, AGSGPUInfo_511* gpuInfo );
+
+///
+/// Function used to initialize the AGS library.
+/// agsVersion must be specified as AGS_MAKE_VERSION( AMD_AGS_VERSION_MAJOR, AMD_AGS_VERSION_MINOR, AMD_AGS_VERSION_PATCH ) or the call will return \ref AGS_INVALID_ARGS.
+/// Must be called prior to any of the subsequent AGS API calls.
+/// Must be called prior to ID3D11Device or ID3D12Device creation.
+/// \note The caller of this function should handle the possibility of the call failing in the cases below. One option is to do a vendor id check and only call \ref agsInitialize if there is an AMD GPU present.
+/// \note This function will fail with \ref AGS_NO_AMD_DRIVER_INSTALLED if there is no AMD driver found on the system.
+/// \note This function will fail with \ref AGS_LEGACY_DRIVER in Catalyst versions before 12.20.
+///
+/// \param [in] agsVersion                          The API version specified using the \ref AGS_MAKE_VERSION macro. If this does not match the version in the binary this initialization call will fail.
+/// \param [in] config                              Optional pointer to a AGSConfiguration struct to override the default library configuration.
+/// \param [out] context                            Address of a pointer to a context. This function allocates a context on the heap which is then required for all subsequent API calls.
+/// \param [out] gpuInfo                            Optional pointer to a AGSGPUInfo struct which will get filled in for all the GPUs in the system.
+///
+AMD_AGS_API AGSReturnCode agsInitialize( int agsVersion, const AGSConfiguration* config, AGSContext** context, AGSGPUInfo_600* gpuInfo );
+
+///
+///   Function used to clean up the AGS library.
+///
+/// \param [in] context                             Pointer to a context. This function will deallocate the context from the heap.
+///
+AMD_AGS_API AGSReturnCode agsDeInit( AGSContext* context );
+
+///
+///   Function used to clean up the AGS library.
+///
+/// \param [in] context                             Pointer to a context. This function will deallocate the context from the heap.
+///
+AMD_AGS_API AGSReturnCode agsDeInitialize( AGSContext* context );
+
+///
+/// Function used to query the number of GPUs used for Crossfire acceleration.
+/// This may be different from the total number of GPUs present in the system.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [out] numGPUs                            Number of GPUs used for Crossfire acceleration
+///
+/// REMOVED IN 5.2.0
+AMD_AGS_API AGSReturnCode agsGetCrossfireGPUCount( AGSContext* context, int* numGPUs );
+
+///
+/// Function used to set a specific display into HDR mode
+/// \note Setting all of the values apart from color space and transfer function to zero will cause the display to use defaults.
+/// \note Call this function after each mode change (switch to fullscreen, any change in swapchain etc).
+/// \note HDR10 PQ mode requires a 1010102 swapchain.
+/// \note HDR10 scRGB mode requires an FP16 swapchain.
+/// \note Freesync HDR scRGB mode requires an FP16 swapchain.
+/// \note Freesync HDR Gamma 2.2 mode requires a 1010102 swapchain.
+/// \note Dolby Vision requires a 8888 UNORM swapchain.
+///
+/// \param [in] context                             Pointer to a context. This is generated by \ref agsInitialize
+/// \param [in] deviceIndex                         The index of the device listed in \ref AGSGPUInfo::devices.
+/// \param [in] displayIndex                        The index of the display listed in \ref AGSDeviceInfo::displays.
+/// \param [in] settings                            Pointer to the display settings to use.
+///
+AMD_AGS_API AGSReturnCode agsSetDisplayMode( AGSContext* context, int deviceIndex, int displayIndex, const AGSDisplaySettings* settings );
+
+/// @}
+
+/// \defgroup dx12 DirectX12 Extensions
+/// DirectX12 driver extensions
+/// @{
+
+/// \defgroup dx12init Device and device object creation and cleanup
+/// It is now mandatory to call \ref agsDriverExtensionsDX12_CreateDevice when creating a device if the user wants to access any future DX12 AMD extensions.
+/// The corresponding \ref agsDriverExtensionsDX12_DestroyDevice call must be called to release the device and free up the internal resources allocated by the create call.
+/// @{
+
+/// The struct to specify the DX12 device creation parameters
+typedef struct AGSDX12DeviceCreationParams
+{
+    IDXGIAdapter*               pAdapter;                   ///< Pointer to the adapter to use when creating the device.  This may be null.
+    IID                         iid;                        ///< The interface ID for the type of device to be created.
+    D3D_FEATURE_LEVEL           FeatureLevel;               ///< The minimum feature level to create the device with.
+} AGSDX12DeviceCreationParams;
+
+/// The struct to specify DX12 additional device creation parameters
+typedef struct AGSDX12ExtensionParams
+{
+    const WCHAR*    pAppName;               ///< Application name
+    const WCHAR*    pEngineName;            ///< Engine name
+    unsigned int    appVersion;             ///< Application version
+    unsigned int    engineVersion;          ///< Engine version
+    // ADDED IN 5.4.0
+    unsigned int    uavSlot;                ///< The UAV slot reserved for intrinsic support.  Refer to the \ref agsDriverExtensionsDX12_CreateDevice documentation for more details.
+} AGSDX12ExtensionParams;
+
+/// The struct to hold all the returned parameters from the device creation call
+typedef struct AGSDX12ReturnedParams
+{
+    ID3D12Device*           pDevice;                ///< The newly created device
+    /*
+        This was changed to a struct in 6.0.0+ but it's still the size of an unsigned int.
+        Ignoring this change for now.
+
+        typedef struct ExtensionsSupported                          /// Extensions for DX12
+        {
+            unsigned int        intrinsics16 : 1;                   ///< Supported in Radeon Software Version 16.9.2 onwards. ReadFirstLane, ReadLane, LaneID, Swizzle, Ballot, MBCount, Med3, Barycentrics
+            unsigned int        intrinsics17 : 1;                   ///< Supported in Radeon Software Version 17.9.1 onwards. WaveReduce, WaveScan
+            unsigned int        userMarkers : 1;                    ///< Supported in Radeon Software Version 17.9.1 onwards.
+            unsigned int        appRegistration : 1;                ///< Supported in Radeon Software Version 17.9.1 onwards.
+            unsigned int        UAVBindSlot : 1;                    ///< Supported in Radeon Software Version 19.5.1 onwards.
+            unsigned int        intrinsics19 : 1;                   ///< Supported in Radeon Software Version 19.12.2 onwards. DrawIndex, AtomicU64
+            unsigned int        baseVertex : 1;                     ///< Supported in Radeon Software Version 20.2.1 onwards.
+            unsigned int        baseInstance : 1;                   ///< Supported in Radeon Software Version 20.2.1 onwards.
+            unsigned int        getWaveSize : 1;                    ///< Supported in Radeon Software Version 20.5.1 onwards.
+            unsigned int        floatConversion : 1;                ///< Supported in Radeon Software Version 20.5.1 onwards.
+            unsigned int        readLaneAt : 1;                     ///< Supported in Radeon Software Version 20.11.2 onwards.
+            unsigned int        rayHitToken : 1;                    ///< Supported in Radeon Software Version 20.11.2 onwards.
+            unsigned int        shaderClock : 1;                    ///< Supported in Radeon Software Version 23.1.1 onwards.
+            unsigned int        padding : 19;                       ///< Reserved
+        } ExtensionsSupported;
+        ExtensionsSupported     extensionsSupported;                ///< List of supported extensions
+    */
+
+    unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX12_CreateDevice will fill in to indicate which extensions are supported. See \ref AGSDriverExtensionDX12
+} AGSDX12ReturnedParams;
+
+
+///
+/// Function used to create a D3D12 device with additional AMD-specific initialization parameters.
+///
+/// When using the HLSL shader extensions please note:
+/// * The shader compiler should not use the D3DCOMPILE_SKIP_OPTIMIZATION (/Od) option, otherwise it will not work.
+/// * The shader compiler needs D3DCOMPILE_ENABLE_STRICTNESS (/Ges) enabled.
+/// * The intrinsic instructions require a 5.1 shader model.
+/// * The Root Signature will need to reserve an extra UAV resource slot. This is not a real resource that requires allocating, it is just used to encode the intrinsic instructions.
+///
+/// The easiest way to set up the reserved UAV slot is to specify it at u0.  The register space id will automatically be assumed to be \ref AGS_DX12_SHADER_INTRINSICS_SPACE_ID.
+/// The HLSL expects this as default and the set up code would look similar to this:
+/// \code{.cpp}
+/// CD3DX12_DESCRIPTOR_RANGE range[];
+/// ...
+/// range[ 0 ].Init( D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 1, 0, AGS_DX12_SHADER_INTRINSICS_SPACE_ID ); // u0 at driver-reserved space id
+/// \endcode
+///
+/// Newer drivers also support a user-specified slot in which case the register space id is assumed to be 0.  It is important that the \ref AGSDX12ReturnedParams::ExtensionsSupported::UAVBindSlot bit is set.
+/// to ensure the driver can support this.  If not, then u0 and \ref AGS_DX12_SHADER_INTRINSICS_SPACE_ID must be used.
+/// If the driver does support this feature and a non zero slot is required, then the HLSL must also define AMD_EXT_SHADER_INTRINSIC_UAV_OVERRIDE as the matching slot value.
+///
+/// \param [in] context                             Pointer to a context. This is generated by \ref agsInitialize
+/// \param [in] creationParams                      Pointer to the struct to specify the existing DX12 device creation parameters.
+/// \param [in] extensionParams                     Optional pointer to the struct to specify DX12 additional device creation parameters.
+/// \param [out] returnedParams                     Pointer to struct to hold all the returned parameters from the call.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_CreateDevice( AGSContext* context, const AGSDX12DeviceCreationParams* creationParams, const AGSDX12ExtensionParams* extensionParams, AGSDX12ReturnedParams* returnedParams );
+
+///
+/// Function to destroy the D3D12 device.
+/// This call will also cleanup any AMD-specific driver extensions for D3D12.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] device                              Pointer to the D3D12 device.
+/// \param [out] deviceReferences                   Optional pointer to an unsigned int that will be set to the value returned from device->Release().
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_DestroyDevice( AGSContext* context, ID3D12Device* device, unsigned int* deviceReferences );
+
+///
+/// Function used to initialize the AMD-specific driver extensions for D3D12.
+/// Extensions require support in the driver, therefore it is important to check the extensionsSupported bitfield.
+///
+/// When using the HLSL shader extensions please note:
+/// * The shader compiler should not use the D3DCOMPILE_SKIP_OPTIMIZATION option, otherwise it will not work.
+/// * The intrinsic instructions require a 5.1 shader model.
+/// * The Root Signature will need to use an extra resource and sampler. These are not real resources/samplers, they are just used to encode the intrinsic instruction.
+///
+/// \param [in] context                             Pointer to a context. This is generated by \ref agsInitialize
+/// \param [in] device                              The D3D12 device.
+/// \param [out] extensionsSupported                Pointer to a bit mask that this function will fill in to indicate which extensions are supported. See ::AGSDriverExtensionDX12
+///
+/// REMOVED IN 5.2.0
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_Init( AGSContext* context, ID3D12Device* device, unsigned int* extensionsSupported );
+
+///
+/// Function used to cleanup any AMD-specific driver extensions for D3D12
+///
+/// \param [in] context                             Pointer to a context.
+///
+/// REMOVED IN 5.2.0
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_DeInit( AGSContext* context );
+
+/// @}
+
+/// \defgroup dx12usermarkers User Markers
+/// @{
+
+///
+/// Function used to push an AMD user marker onto the command list.
+/// This is only has an effect if \ref AGSDX12ReturnedParams::ExtensionsSupported::userMarkers is present.
+/// Supported in Radeon Software Version 17.9.1 onwards.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] commandList                         Pointer to the command list.
+/// \param [in] data                                The marker string.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_PushMarker( AGSContext* context, ID3D12GraphicsCommandList* commandList, const char* data );
+
+///
+/// Function used to pop an AMD user marker on the command list.
+/// Supported in Radeon Software Version 17.9.1 onwards.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] commandList                         Pointer to the command list.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_PopMarker( AGSContext* context, ID3D12GraphicsCommandList* commandList );
+
+///
+/// Function used to insert an single event AMD user marker onto the command list.
+/// Supported in Radeon Software Version 17.9.1 onwards.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] commandList                         Pointer to the command list.
+/// \param [in] data                                The marker string.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX12_SetMarker( AGSContext* context, ID3D12GraphicsCommandList* commandList, const char* data );
+
+/// @}
+
+/// @}
+
+/// \defgroup dx11 DirectX11 Extensions
+/// DirectX11 driver extensions
+/// @{
+
+/// \defgroup dx11init Device creation and cleanup
+/// It is now mandatory to call \ref agsDriverExtensionsDX11_CreateDevice when creating a device if the user wants to access any DX11 AMD extensions.
+/// The corresponding \ref agsDriverExtensionsDX11_DestroyDevice call must be called to release the device and free up the internal resources allocated by the create call.
+/// @{
+
+/// The different modes to control Crossfire behavior.
+typedef enum AGSCrossfireMode
+{
+    AGS_CROSSFIRE_MODE_DRIVER_AFR = 0,                      ///< Use the default driver-based AFR rendering.  If this mode is specified, do NOT use the agsDriverExtensionsDX11_Create*() APIs to create resources
+    AGS_CROSSFIRE_MODE_EXPLICIT_AFR,                        ///< Use the AGS Crossfire API functions to perform explicit AFR rendering without requiring a CF driver profile
+    AGS_CROSSFIRE_MODE_DISABLE                              ///< Completely disable AFR rendering
+} AGSCrossfireMode;
+
+/// The struct to specify the existing DX11 device creation parameters
+typedef struct AGSDX11DeviceCreationParams
+{
+    IDXGIAdapter*               pAdapter;                   ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    D3D_DRIVER_TYPE             DriverType;                 ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    HMODULE                     Software;                   ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    UINT                        Flags;                      ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    const D3D_FEATURE_LEVEL*    pFeatureLevels;             ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    UINT                        FeatureLevels;              ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    UINT                        SDKVersion;                 ///< Consult the DX documentation on D3D11CreateDevice for this parameter
+    const DXGI_SWAP_CHAIN_DESC* pSwapChainDesc;             ///< Optional swapchain description. Specify this to invoke D3D11CreateDeviceAndSwapChain instead of D3D11CreateDevice. This must be null on the WACK compliant version
+} AGSDX11DeviceCreationParams;
+
+/// The struct to specify DX11 additional device creation parameters
+typedef struct AGSDX11ExtensionParams_511
+{
+    unsigned int    uavSlot;           ///< The UAV slot reserved for intrinsic support. This must match the slot defined in the HLSL, i.e. #define AmdDxExtShaderIntrinsicsUAVSlot.
+                                       /// The default slot is 7, but the caller is free to use an alternative slot.
+    const WCHAR*    pAppName;          ///< Application name
+    UINT            appVersion;        ///< Application version
+    const WCHAR*    pEngineName;       ///< Engine name
+    UINT            engineVersion;     ///< Engine version
+} AGSDX11ExtensionParams_511;
+
+typedef struct AGSDX11ExtensionParams_520
+{
+    const WCHAR*                pAppName;                   ///< Application name
+    const WCHAR*                pEngineName;                ///< Engine name
+    unsigned int                appVersion;                 ///< Application version
+    unsigned int                engineVersion;              ///< Engine version
+    unsigned int                numBreadcrumbMarkers;       ///< The number of breadcrumb markers to allocate. Each marker is a uint64 (ie 8 bytes). If 0, the system is disabled.
+    unsigned int                uavSlot;                    ///< The UAV slot reserved for intrinsic support. This must match the slot defined in the HLSL, i.e. "#define AmdDxExtShaderIntrinsicsUAVSlot".
+                                                            /// The default slot is 7, but the caller is free to use an alternative slot.
+                                                            /// If 0 is specified, then the default of 7 will be used.
+    AGSCrossfireMode            crossfireMode;              ///< Desired Crossfire mode
+} AGSDX11ExtensionParams_520;
+
+typedef union AGSDX11ExtensionParams
+{
+    AGSDX11ExtensionParams_511   agsDX11ExtensionParams511;
+    AGSDX11ExtensionParams_520   agsDX11ExtensionParams520;
+} AGSDX11ExtensionParams;
+
+/// The struct to hold all the returned parameters from the device creation call
+typedef struct AGSDX11ReturnedParams_511
+{
+    ID3D11Device*           pDevice;                ///< The newly created device
+    D3D_FEATURE_LEVEL       FeatureLevel;           ///< The feature level supported by the newly created device
+    ID3D11DeviceContext*    pImmediateContext;      ///< The newly created immediate device context
+    IDXGISwapChain*         pSwapChain;             ///< The newly created swap chain. This is only created if a valid pSwapChainDesc is supplied in AGSDX11DeviceCreationParams. This is not supported on the WACK compliant version
+    unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX11_CreateDevice will fill in to indicate which extensions are supported. See AGSDriverExtensionDX11
+} AGSDX11ReturnedParams_511;
+
+typedef struct AGSDX11ReturnedParams_520
+{
+    ID3D11Device*           pDevice;                ///< The newly created device
+    ID3D11DeviceContext*    pImmediateContext;      ///< The newly created immediate device context
+    IDXGISwapChain*         pSwapChain;             ///< The newly created swap chain. This is only created if a valid pSwapChainDesc is supplied in AGSDX11DeviceCreationParams. This is not supported on the WACK compliant version
+    D3D_FEATURE_LEVEL       FeatureLevel;           ///< The feature level supported by the newly created device
+    unsigned int            extensionsSupported;    ///< Bit mask that \ref agsDriverExtensionsDX11_CreateDevice will fill in to indicate which extensions are supported. See \ref AGSDriverExtensionDX11
+    unsigned int            crossfireGPUCount;      ///< The number of GPUs that are active for this app
+    void*                   breadcrumbBuffer;       ///< The CPU buffer returned if the initialization of the breadcrumb was successful.
+} AGSDX11ReturnedParams_520;
+
+typedef struct AGSDX11ExtensionsSupported_600               /// Extensions for DX11
+{
+    unsigned int        quadList : 1;                       ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        screenRectList : 1;                 ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        uavOverlap : 1;                     ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        depthBoundsTest : 1;                ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        multiDrawIndirect : 1;              ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        multiDrawIndirectCountIndirect : 1; ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        crossfireAPI : 1;                   ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        createShaderControls : 1;           ///< Supported in Radeon Software Version 16.9.2 onwards.
+    unsigned int        intrinsics16 : 1;                   ///< Supported in Radeon Software Version 16.9.2 onwards. ReadFirstLane, ReadLane, LaneID, Swizzle, Ballot, MBCount, Med3, Barycentrics
+    unsigned int        multiView : 1;                      ///< Supported in Radeon Software Version 16.12.1 onwards.
+    unsigned int        intrinsics17 : 1;                   ///< Supported in Radeon Software Version 17.9.1 onwards. WaveReduce, WaveScan
+    unsigned int        appRegistration : 1;                ///< Supported in Radeon Software Version 17.9.1 onwards.
+    unsigned int        breadcrumbMarkers : 1;              ///< Supported in Radeon Software Version 17.11.1 onwards.
+    unsigned int        MDIDeferredContexts : 1;            ///< Supported in Radeon Software Version 18.8.1 onwards.
+    unsigned int        UAVOverlapDeferredContexts : 1;     ///< Supported in Radeon Software Version 18.8.1 onwards.
+    unsigned int        depthBoundsDeferredContexts : 1;    ///< Supported in Radeon Software Version 18.8.1 onwards.
+    unsigned int        intrinsics19 : 1;                   ///< Supported in Radeon Software Version 19.12.2 onwards. DrawIndex, AtomicU64
+    unsigned int        getWaveSize : 1;                    ///< Supported in Radeon Software Version 20.2.1 onwards.
+    unsigned int        baseVertex : 1;                     ///< Supported in Radeon Software Version 20.2.1 onwards.
+    unsigned int        baseInstance : 1;                   ///< Supported in Radeon Software Version 20.2.1 onwards.
+    unsigned int        padding : 12;                       ///< Reserved
+} AGSDX11ExtensionsSupported_600;
+
+typedef struct AGSDX11ReturnedParams_600
+{
+    ID3D11Device*                  pDevice;                 ///< The newly created device
+    ID3D11DeviceContext*           pImmediateContext;       ///< The newly created immediate device context
+    IDXGISwapChain*                pSwapChain;              ///< The newly created swap chain. This is only created if a valid pSwapChainDesc is supplied in AGSDX11DeviceCreationParams.
+    D3D_FEATURE_LEVEL              featureLevel;            ///< The feature level supported by the newly created device
+    AGSDX11ExtensionsSupported_600 extensionsSupported;     ///< List of supported extensions
+    unsigned int                   crossfireGPUCount;       ///< The number of GPUs that are active for this app
+    void*                          breadcrumbBuffer;        ///< The CPU buffer returned if the initialization of the breadcrumb was successful
+} AGSDX11ReturnedParams_600;
+
+typedef union AGSDX11ReturnedParams
+{
+    AGSDX11ReturnedParams_511   agsDX11ReturnedParams511;
+    AGSDX11ReturnedParams_520   agsDX11ReturnedParams520;
+    AGSDX11ReturnedParams_600   agsDX11ReturnedParams600;
+} AGSDX11ReturnedParams;
+
+///
+/// Function used to create a D3D11 device with additional AMD-specific initialization parameters.
+///
+/// When using the HLSL shader extensions please note:
+/// * The shader compiler should not use the D3DCOMPILE_SKIP_OPTIMIZATION (/Od) option, otherwise it will not work.
+/// * The shader compiler needs D3DCOMPILE_ENABLE_STRICTNESS (/Ges) enabled.
+///
+/// \param [in] context                             Pointer to a context. This is generated by \ref agsInititalize
+/// \param [in] creationParams                      Pointer to the struct to specify the existing DX11 device creation parameters.
+/// \param [in] extensionParams                     Optional pointer to the struct to specify DX11 additional device creation parameters.
+/// \param [out] returnedParams                     Pointer to struct to hold all the returned parameters from the call.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateDevice( AGSContext* context, const AGSDX11DeviceCreationParams* creationParams, const AGSDX11ExtensionParams* extensionParams, AGSDX11ReturnedParams* returnedParams );
+
+///
+/// Function to destroy the D3D11 device and its immediate context.
+/// This call will also cleanup any AMD-specific driver extensions for D3D11.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] device                              Pointer to the D3D11 device.
+/// \param [out] deviceReferences                   Optional pointer to an unsigned int that will be set to the value returned from device->Release().
+/// \param [in] immediateContext                    Pointer to the D3D11 immediate device context.
+/// \param [out] immediateContextReferences         Optional pointer to an unsigned int that will be set to the value returned from immediateContext->Release().
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice_520( AGSContext* context, ID3D11Device* device, unsigned int* deviceReferences, ID3D11DeviceContext* immediateContext, unsigned int* immediateContextReferences );
+
+
+///
+/// Function to destroy the D3D11 device.
+/// This call will also cleanup any AMD-specific driver extensions for D3D11.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] device                              Pointer to the D3D11 device.
+/// \param [out] references                         Optional pointer to an unsigned int that will be set to the value returned from device->Release().
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_DestroyDevice_511( AGSContext* context, ID3D11Device* device, unsigned int* references );
+
+/// @}
+
+
+/// \defgroup dx11appreg App Registration
+/// @{
+/// This extension allows an apllication to voluntarily register itself with the driver, providing a more robust app detection solution and avoid the issue of the driver 
+/// relying on exe names to match the app to a driver profile.
+/// This feature is supported in Radeon Software Version 17.9.2 onwards.
+/// Rules:
+/// * AppName or EngineName must be set, but both are not required. Engine profiles will be used only if app specific profiles do not exist.
+/// * In an engine, the EngineName should be set, so a default profile can be built. If an app modifies the engine, the AppName should be set, to allow a profile for the specific app.
+/// * Version number is not mandatory, but heavily suggested. The use of which can prevent the use of profiles for incompatible versions (for instance engine versions that introduce or change features), and can help prevent older profiles from being used (and introducing new bugs) before the profile is tested with new app builds.
+/// * If Version numbers are used and a new version is introduced, a new profile will not be enabled until an AMD engineer has been able to update a previous profile, or make a new one.
+///
+/// The cases for profile selection are as follows:
+///
+/// |Case|Profile Applied|
+/// |----|---------------|
+/// | App or Engine Version has profile | The profile is used. |
+/// | App or Engine Version num < profile version num | The closest profile > the version number is used. |
+/// | App or Engine Version num > profile version num | No profile selected/The previous method is used. |
+/// | App and Engine Version have profile | The App's profile is used. |
+/// | App and Engine Version num < profile version | The closest App profile > the version number is used. |
+/// | App and Engine Version, no App profile found | The Engine profile will be used. |
+/// | App/Engine name but no Version, has profile | The latest profile is used. |
+/// | No name or version, or no profile | The previous app detection method is used. |
+///
+/// As shown above, if an App name is given, and a profile is found for that app, that will be prioritized. The Engine name and profile will be used only if no app name is given, or no viable profile is found for the app name.
+/// In the case that App nor Engine have a profile, the previous app detection methods will be used. If given a version number that is larger than any profile version number, no profile will be selected.
+/// This is specifically to prevent cases where an update to an engine or app will cause catastrophic  breaks in the profile, allowing an engineer to test the profile before clearing it for public use with the new engine/app update.
+///
+/// @}
+
+/// \defgroup breadcrumbs Breadcrumb API
+/// API for writing top-of-pipe and bottom-of-pipe markers to help track down GPU hangs.
+///
+/// The API is available if the \ref AGSDX11ReturnedParams::ExtensionsSupported::breadcrumbMarkers is present.
+///
+/// To use the API, a non zero value needs to be specificed in \ref AGSDX11ExtensionParams::numBreadcrumbMarkers.  This enables the API (if available) and allocates a system memory buffer
+/// which is returned to the user in \ref AGSDX11ReturnedParams::breadcrumbBuffer.
+///
+/// The user can now write markers before and after draw calls using \ref agsDriverExtensionsDX11_WriteBreadcrumb.
+///
+/// \section background Background
+///
+/// A top-of-pipe (TOP) command is scheduled for execution as soon as the command processor (CP) reaches the command.
+/// A bottom-of-pipe (BOP) command is scheduled for execution once the previous rendering commands (draw and dispatch) finish execution.
+/// TOP and BOP commands do not block CP. i.e. the CP schedules the command for execution then proceeds to the next command without waiting.
+/// To effectively use TOP and BOP commands, it is important to understand how they interact with rendering commands:
+///
+/// When the CP encounters a rendering command it queues it for execution and moves to the next command.  The queued rendering commands are issued in order.
+/// There can be multiple rendering commands running in parallel.  When a rendering command is issued we say it is at the top of the pipe.  When a rendering command
+/// finishes execution we say it has reached the bottom of the pipe.
+///
+/// A BOP command remains in a waiting queue and is executed once prior rendering commands finish.  The queue of BOP commands is limited to 64 entries in GCN generation 1, 2, 3, 4 and 5.
+/// If the 64 limit is reached the CP will stop queueing BOP commands and also rendering commands.  Developers should limit the number of BOP commands that write markers to avoid contention.
+/// In general, developers should limit both TOP and BOP commands to avoid stalling the CP.
+///
+/// \subsection eg1 Example 1:
+///
+/// \code{.cpp}
+/// // Start of a command buffer
+/// WriteMarker(TopOfPipe, 1)
+/// WriteMarker(BottomOfPipe, 2)
+/// WriteMarker(BottomOfPipe, 3)
+/// DrawX
+/// WriteMarker(BottomOfPipe, 4)
+/// WriteMarker(BottomOfPipe, 5)
+/// WriteMarker(TopOfPipe, 6)
+/// // End of command buffer
+/// \endcode
+///
+/// In the above example, the CP writes markers 1, 2 and 3 without waiting:
+/// Marker 1 is TOP so it's independent from other commands
+/// There's no wait for marker 2 and 3 because there are no draws preceding the BOP commands
+/// Marker 4 is only written once DrawX finishes execution
+/// Marker 5 doesn't wait for additional draws so it is written right after marker 4
+/// Marker 6 can be written as soon as the CP reaches the command. For instance, it is very possible that CP writes marker 6 while DrawX 
+/// is running and therefore marker 6 gets written before markers 4 and 5
+///
+/// \subsection eg2 Example 2:
+///
+/// \code{.cpp}
+/// WriteMarker(TopOfPipe, 1)
+/// DrawX
+/// WriteMarker(BottomOfPipe, 2)
+/// WriteMarker(TopOfPipe, 3)
+/// DrawY
+/// WriteMarker(BottomOfPipe, 4)
+/// \endcode
+///
+/// In this example marker 1 is written before the start of DrawX
+/// Marker 2 is written once DrawX finishes execution
+/// Similarly marker 3 is written before the start of DrawY
+/// Marker 4 is written once DrawY finishes execution
+/// In case of a GPU hang, if markers 1 and 3 are written but markers 2 and 4 are missing we can conclude that:
+/// The CP has reached both DrawX and DrawY commands since marker 1 and 3 are present
+/// The fact that marker 2 and 4 are missing means that either DrawX is hanging while DrawY is at the top of the pipe or both DrawX and DrawY
+/// started and both are simultaneously hanging
+///
+/// \subsection eg3 Example 3:
+///
+/// \code{.cpp}
+/// // Start of a command buffer
+/// WriteMarker(BottomOfPipe, 1)
+/// DrawX
+/// WriteMarker(BottomOfPipe, 2)
+/// DrawY
+/// WriteMarker(BottomOfPipe, 3)
+/// DrawZ
+/// WriteMarker(BottomOfPipe, 4)
+/// // End of command buffer
+/// \endcode
+///
+/// In this example marker 1 is written before the start of DrawX
+/// Marker 2 is written once DrawX finishes
+/// Marker 3 is written once DrawY finishes
+/// Marker 4 is written once DrawZ finishes 
+/// If the GPU hangs and only marker 1 is written we can conclude that the hang is happening in either DrawX, DrawY or DrawZ
+/// If the GPU hangs and only marker 1 and 2 are written we can conclude that the hang is happening in DrawY or DrawZ
+/// If the GPU hangs and only marker 4 is missing we can conclude that the hang is happening in DrawZ
+///
+/// \subsection eg4 Example 4:
+///
+/// \code{.cpp}
+/// Start of a command buffer
+/// WriteMarker(TopOfPipe, 1)
+/// DrawX
+/// WriteMarker(TopOfPipe, 2)
+/// DrawY
+/// WriteMarker(TopOfPipe, 3)
+/// DrawZ
+/// // End of command buffer
+/// \endcode
+///
+/// In this example, in case the GPU hangs and only marker 1 is written we can conclude that the hang is happening in DrawX
+/// In case the GPU hangs and only marker 1 and 2 are written we can conclude that the hang is happening in DrawX or DrawY
+/// In case the GPU hangs and all 3 markers are written we can conclude that the hang is happening in any of DrawX, DrawY or DrawZ
+///
+/// \subsection eg5 Example 5:
+///
+/// \code{.cpp}
+/// DrawX
+/// WriteMarker(TopOfPipe, 1)
+/// WriteMarker(BottomOfPipe, 2)
+/// DrawY
+/// WriteMarker(TopOfPipe, 3)
+/// WriteMarker(BottomOfPipe, 4)
+/// \endcode
+///
+/// Marker 1 is written right after DrawX is queued for execution.
+/// Marker 2 is only written once DrawX finishes execution.
+/// Marker 3 is written right after DrawY is queued for execution.
+/// Marker 4 is only written once DrawY finishes execution
+/// If marker 1 is written we would know that the CP has reached the command DrawX (DrawX at the top of the pipe).
+/// If marker 2 is written we can say that DrawX has finished execution (DrawX at the bottom of the pipe). 
+/// In case the GPU hangs and only marker 1 and 3 are written we can conclude that the hang is happening in DrawX or DrawY
+/// In case the GPU hangs and only marker 1 is written we can conclude that the hang is happening in DrawX
+/// In case the GPU hangs and only marker 4 is missing we can conclude that the hang is happening in DrawY
+///
+/// \section data Retrieving GPU Data
+///
+/// In the event of a GPU hang, the user can inspect the system memory buffer to determine which draw has caused the hang.
+/// For example:
+/// \code{.cpp}
+///     // Force the work to be flushed to prevent CPU ahead of GPU
+///     g_pImmediateContext->Flush();
+///     
+///     // Present the information rendered to the back buffer to the front buffer (the screen)
+///     HRESULT hr = g_pSwapChain->Present( 0, 0 );
+///     
+///     // Read the marker data buffer once detect device lost
+///     if ( hr != S_OK )
+///     {
+///         for (UINT i = 0; i < g_NumMarkerWritten; i++)
+///         {
+///             UINT64* pTempData;
+///             pTempData = static_cast<UINT64*>(pMarkerBuffer);
+/// 
+///             // Write the marker data to file
+///             ofs << i << "\r\n";
+///             ofs << std::hex << *(pTempData + i * 2) << "\r\n";
+///             ofs << std::hex << *(pTempData + (i * 2 + 1)) << "\r\n";
+/// 
+///             WCHAR s1[256];
+///             setlocale(LC_NUMERIC, "en_US.iso88591");
+/// 
+///             // Output the marker data to console
+///             swprintf(s1, 256, L" The Draw count is %d; The Top maker is % 016llX and the Bottom marker is % 016llX \r\n", i, *(pTempData + i * 2), *(pTempData + (i * 2 + 1)));
+/// 
+///             OutputDebugStringW(s1);
+///         }
+///     }
+/// \endcode
+///
+/// The console output would resemble something like:
+/// \code{.cpp}
+/// D3D11: Removing Device. 
+/// D3D11 ERROR: ID3D11Device::RemoveDevice: Device removal has been triggered for the following reason (DXGI_ERROR_DEVICE_HUNG: The Device took an unreasonable amount of time to execute its commands, or the hardware crashed/hung. As a result, the TDR (Timeout Detection and Recovery) mechanism has been triggered. The current Device Context was executing commands when the hang occurred. The application may want to respawn and fallback to less aggressive use of the display hardware). [ EXECUTION ERROR #378: DEVICE_REMOVAL_PROCESS_AT_FAULT]
+///  The Draw count is 0; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 1; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 2; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 3; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 4; The Top maker is 00000000DEADCAFE and the Bottom marker is 00000000DEADBEEF 
+///  The Draw count is 5; The Top maker is CDCDCDCDCDCDCDCD and the Bottom marker is CDCDCDCDCDCDCDCD 
+///  The Draw count is 6; The Top maker is CDCDCDCDCDCDCDCD and the Bottom marker is CDCDCDCDCDCDCDCD 
+///  The Draw count is 7; The Top maker is CDCDCDCDCDCDCDCD and the Bottom marker is CDCDCDCDCDCDCDCD 
+/// \endcode
+/// 
+/// @{
+
+/// The breadcrumb marker struct used by \ref agsDriverExtensionsDX11_WriteBreadcrumb
+typedef struct AGSBreadcrumbMarker
+{
+    unsigned long long  markerData; ///< The user data to write.
+    enum
+    {
+        TopOfPipe       = 0,    ///< Top-of-pipe marker
+        BottomOfPipe    = 1     ///< Bottom-of-pipe marker
+    }                   type;       ///< Whether this marker is top or bottom of pipe.
+    unsigned int        index;      ///< The index of the marker. This should be less than the value specified in \ref AGSDX11ExtensionParams::numBreadcrumbMarkers
+} AGSBreadcrumbMarker;
+
+///
+/// Function to write a breadcrumb marker.
+///
+/// This method inserts a write marker operation in the GPU command stream. In the case where the GPU is hanging the write
+/// command will never be reached and the marker will never get written to memory.
+///
+/// In order to use this function, \ref AGSDX11ExtensionParams::numBreadcrumbMarkers must be set to a non zero value.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] marker                              Pointer to a marker.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_WriteBreadcrumb( AGSContext* context, const AGSBreadcrumbMarker* marker );
+
+/// @}
+
+/// \defgroup dx11Topology Extended Topology
+/// API for primitive topologies
+/// @{
+
+/// Additional topologies supported via extensions
+typedef enum AGSPrimitiveTopologyDX11
+{
+    AGS_PRIMITIVE_TOPOLOGY_QUADLIST                         = 7,    ///< Quad list
+    AGS_PRIMITIVE_TOPOLOGY_SCREENRECTLIST                   = 9     ///< Screen rect list
+} AGSPrimitiveTopologyDX11;
+
+///
+/// Function used to set the primitive topology. If you are using any of the extended topology types, then this function should
+/// be called to set ALL topology types.
+///
+/// The Quad List extension is a convenient way to submit quads without using an index buffer. Note that this still submits two triangles at the driver level. 
+/// In order to use this function, AGS must already be initialized and agsDriverExtensionsDX11_Init must have been called successfully.
+///
+/// The Screen Rect extension, which is only available on GCN hardware, allows the user to pass in three of the four corners of a rectangle. 
+/// The hardware then uses the bounding box of the vertices to rasterize the rectangle primitive (i.e. as a rectangle rather than two triangles). 
+/// \note Note that this will not return valid interpolated values, only valid SV_Position values.
+/// \note If either the Quad List or Screen Rect extension are used, then agsDriverExtensionsDX11_IASetPrimitiveTopology should be called in place of the native DirectX11 equivalent all the time.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] topology                            The topology to set on the D3D11 device. This can be either an AGS-defined topology such as AGS_PRIMITIVE_TOPOLOGY_QUADLIST
+///                                                 or a standard D3D-defined topology such as D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP.
+///                                                 NB. the AGS-defined types will require casting to a D3D_PRIMITIVE_TOPOLOGY type.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_IASetPrimitiveTopology( AGSContext* context, enum D3D_PRIMITIVE_TOPOLOGY topology );
+
+/// @}
+
+/// \defgroup dx11UAVOverlap UAV Overlap
+/// API for enabling overlapping UAV writes
+/// @{
+
+///
+/// Function used indicate to the driver that it doesn't need to sync the UAVs bound for the subsequent set of back-to-back dispatches.
+/// When calling back-to-back draw calls or dispatch calls that write to the same UAV, the AMD DX11 driver will automatically insert a barrier to ensure there are no write after write (WAW) hazards.
+/// If the app can guarantee there is no overlap between the writes between these calls, then this extension will remove those barriers allowing the work to run in parallel on the GPU.
+///
+/// Usage would be as follows:
+/// \code{.cpp}
+///     m_device->Dispatch( ... );  // First call that writes to the UAV
+///
+///     // Disable automatic WAW syncs
+///     agsDriverExtensionsDX11_BeginUAVOverlap( m_agsContext );
+///
+///     // Submit other dispatches that write to the same UAV concurrently
+///     m_device->Dispatch( ... );
+///     m_device->Dispatch( ... );
+///     m_device->Dispatch( ... );
+///
+///     // Reenable automatic WAW syncs
+///     agsDriverExtensionsDX11_EndUAVOverlap( m_agsContext );
+/// \endcode
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+///                                                 with the AGS_DX11_EXTENSION_DEFERRED_CONTEXTS bit.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_BeginUAVOverlap_520( AGSContext* context );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_BeginUAVOverlap( AGSContext* context, ID3D11DeviceContext* dxContext );
+
+///
+/// Function used indicate to the driver it can no longer overlap the batch of back-to-back dispatches that has been submitted.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+///                                                 with the AGS_DX11_EXTENSION_DEFERRED_CONTEXTS bit.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_EndUAVOverlap_520( AGSContext* context );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_EndUAVOverlap( AGSContext* context, ID3D11DeviceContext* dxContext );
+
+/// @}
+
+/// \defgroup dx11DepthBoundsTest Depth Bounds Test
+/// API for enabling depth bounds testing
+/// @{
+
+///
+/// Function used to set the depth bounds test extension
+///
+/// \param [in] context                             Pointer to a context
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+/// \param [in] enabled                             Whether to enable or disable the depth bounds testing. If disabled, the next two args are ignored.
+/// \param [in] minDepth                            The near depth range to clip against.
+/// \param [in] maxDepth                            The far depth range to clip against.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds( AGSContext* context, bool enabled, float minDepth, float maxDepth );
+
+/* Since 5.3.0 */
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDepthBounds_530( AGSContext* context, ID3D11DeviceContext* dxContext, bool enabled, float minDepth, float maxDepth );
+
+/// @}
+
+/// \defgroup mdi Multi Draw Indirect (MDI)
+/// API for dispatching multiple instanced draw commands.
+/// The multi draw indirect extensions allow multiple sets of DrawInstancedIndirect to be submitted in one API call.
+/// The draw calls are issued on the GPU's command processor (CP), potentially saving the significant CPU overheads incurred by submitting the equivalent draw calls on the CPU.
+///
+/// The extension allows the following code:
+/// \code{.cpp}
+///     // Submit n batches of DrawIndirect calls
+///     for ( int i = 0; i < n; i++ )
+///         deviceContext->DrawIndexedInstancedIndirect( buffer, i * sizeof( cmd ) );
+/// \endcode
+/// To be replaced by the following call:
+/// \code{.cpp}
+///     // Submit all n batches in one call
+///     agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect( m_agsContext, deviceContext, n, buffer, 0, sizeof( cmd ) );
+/// \endcode
+///
+/// The buffer used for the indirect args must be of the following formats:
+/// \code{.cpp}
+///     // Buffer layout for agsDriverExtensions_MultiDrawInstancedIndirect
+///     struct DrawInstancedIndirectArgs
+///     {
+///         UINT VertexCountPerInstance;
+///         UINT InstanceCount;
+///         UINT StartVertexLocation;
+///         UINT StartInstanceLocation;
+///     };
+///
+///     // Buffer layout for agsDriverExtensions_MultiDrawIndexedInstancedIndirect
+///     struct DrawIndexedInstancedIndirectArgs
+///     {
+///         UINT IndexCountPerInstance;
+///         UINT InstanceCount;
+///         UINT StartIndexLocation;
+///         UINT BaseVertexLocation;
+///         UINT StartInstanceLocation;
+///     };
+/// \endcode
+///
+/// Example usage can be seen in AMD's GeometryFX (https://github.com/GPUOpen-Effects/GeometryFX).  In particular, in this file: https://github.com/GPUOpen-Effects/GeometryFX/blob/master/amd_geometryfx/src/AMD_GeometryFX_Filtering.cpp
+///
+/// @{
+
+///
+/// Function used to submit a batch of draws via MultiDrawIndirect
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+/// \param [in] drawCount                           The number of draws.
+/// \param [in] pBufferForArgs                      The args buffer.
+/// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
+/// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirect_520( AGSContext* context, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+
+///
+/// Function used to submit a batch of draws via MultiDrawIndirect
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+/// \param [in] drawCount                           The number of draws.
+/// \param [in] pBufferForArgs                      The args buffer.
+/// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
+/// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect_520( AGSContext* context, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, unsigned int drawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+
+///
+/// Function used to submit a batch of draws via MultiDrawIndirect
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+/// \param [in] pBufferForDrawCount                 The draw count buffer.
+/// \param [in] alignedByteOffsetForDrawCount       The offset into the draw count buffer.
+/// \param [in] pBufferForArgs                      The args buffer.
+/// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
+/// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect_520( AGSContext* context, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+
+///
+/// Function used to submit a batch of draws via MultiDrawIndirect
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] dxContext                           Pointer to the DirectX device context.  If this is to work using the non-immediate context, then you need to check support.  If nullptr is specified, then the immediate context is assumed.
+/// \param [in] pBufferForDrawCount                 The draw count buffer.
+/// \param [in] alignedByteOffsetForDrawCount       The offset into the draw count buffer.
+/// \param [in] pBufferForArgs                      The args buffer.
+/// \param [in] alignedByteOffsetForArgs            The offset into the args buffer.
+/// \param [in] byteStrideForArgs                   The per element stride of the args buffer.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect_520( AGSContext* context, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect( AGSContext* context, ID3D11DeviceContext* dxContext, ID3D11Buffer* pBufferForDrawCount, unsigned int alignedByteOffsetForDrawCount, ID3D11Buffer* pBufferForArgs, unsigned int alignedByteOffsetForArgs, unsigned int byteStrideForArgs );
+
+/// @}
+
+/// \defgroup shadercompiler Shader Compiler Controls
+/// API for controlling DirectX11 shader compilation.
+/// Check support for this feature using the AGS_DX11_EXTENSION_CREATE_SHADER_CONTROLS bit.
+/// Supported in Radeon Software Version 16.9.2 (driver version 16.40.2311) onwards.
+/// @{
+
+///
+/// This method can be used to limit the maximum number of threads the driver uses for asynchronous shader compilation.
+/// Setting it to 0 will disable asynchronous compilation completely and force the shaders to be compiled "inline" on the threads that call Create*Shader.
+///
+/// This method can only be called before any shaders are created and being compiled by the driver.
+/// If this method is called after shaders have been created the function will return AGS_FAILURE.
+/// This function only sets an upper limit.The driver may create fewer threads than allowed by this function.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] numberOfThreads                     The maximum number of threads to use.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetMaxAsyncCompileThreadCount( AGSContext* context, unsigned int numberOfThreads );
+
+///
+/// This method can be used to determine the total number of asynchronous shader compile jobs that are either
+/// queued for waiting for compilation or being compiled by the driver's asynchronous compilation threads.
+/// This method can be called at any during the lifetime of the driver.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [out] numberOfJobs                       Pointer to the number of jobs in flight currently.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_NumPendingAsyncCompileJobs( AGSContext* context, unsigned int* numberOfJobs );
+
+///
+/// This method can be used to enable or disable the disk based shader cache.
+/// Enabling/disabling the disk cache is not supported if is it disabled explicitly via Radeon Settings or by an app profile.
+/// Calling this method under these conditions will result in AGS_FAILURE being returned.
+/// It is recommended that this method be called before any shaders are created by the application and being compiled by the driver.
+/// Doing so at any other time may result in the cache being left in an inconsistent state.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] enable                              Whether to enable the disk cache. 0 to disable, 1 to enable.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetDiskShaderCacheEnabled( AGSContext* context, int enable );
+
+/// @}
+
+/// \defgroup multiview Multiview
+/// API for multiview broadcasting.
+/// Check support for this feature using the AGS_DX11_EXTENSION_MULTIVIEW bit.
+/// Supported in Radeon Software Version 16.12.1 (driver version 16.50.2001) onwards.
+/// @{
+
+///
+/// Function to control draw calls replication to multiple viewports and RT slices.
+/// Setting any mask to 0 disables draw replication.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] vpMask                              Viewport control bit mask.
+/// \param [in] rtSliceMask                         RT slice control bit mask.
+/// \param [in] vpMaskPerRtSliceEnabled             If 0, 16 lower bits of vpMask apply to all RT slices; if 1 each 16 bits of 64-bit mask apply to corresponding 4 RT slices.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetViewBroadcastMasks( AGSContext* context, unsigned long long vpMask, unsigned long long rtSliceMask, int vpMaskPerRtSliceEnabled );
+
+///
+/// Function returns max number of supported clip rectangles.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [out] maxRectCount                       Returned max number of clip rectangles.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_GetMaxClipRects( AGSContext* context, unsigned int* maxRectCount );
+
+/// The inclusion mode for the rect
+typedef enum AGSClipRect_Mode
+{
+    ClipRectIncluded = 0,   ///< Include the rect
+    ClipRectExcluded = 1    ///< Exclude the rect
+} AGSClipRect_Mode;
+
+/// The clip rectangle struct used by \ref agsDriverExtensionsDX11_SetClipRects
+typedef struct AGSClipRect
+{
+    AGSClipRect_Mode mode; ///< Include/exclude rect region
+    AGSRect          rect; ///< The rect to include/exclude
+} AGSClipRect; 
+
+
+
+///
+/// Function sets clip rectangles.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] clipRectCount                       Number of specified clip rectangles. Use 0 to disable clip rectangles.
+/// \param [in] clipRects                           Array of clip rectangles.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_SetClipRects( AGSContext* context, unsigned int clipRectCount, const AGSClipRect* clipRects );
+
+/// @}
+
+/// \defgroup cfxapi Explicit Crossfire API
+/// API for explicit control over Crossfire
+/// @{
+
+/// The Crossfire API transfer types
+typedef enum AGSAfrTransferType
+{
+    AGS_AFR_TRANSFER_DEFAULT                                = 0,    ///< Default Crossfire driver resource tracking
+    AGS_AFR_TRANSFER_DISABLE                                = 1,    ///< Turn off driver resource tracking
+    AGS_AFR_TRANSFER_1STEP_P2P                              = 2,    ///< App controlled GPU to next GPU transfer
+    AGS_AFR_TRANSFER_2STEP_NO_BROADCAST                     = 3,    ///< App controlled GPU to next GPU transfer using intermediate system memory
+    AGS_AFR_TRANSFER_2STEP_WITH_BROADCAST                   = 4,    ///< App controlled GPU to all render GPUs transfer using intermediate system memory
+} AGSAfrTransferType;
+
+/// The Crossfire API transfer engines
+typedef enum AGSAfrTransferEngine
+{
+    AGS_AFR_TRANSFERENGINE_DEFAULT                          = 0,    ///< Use default engine for Crossfire API transfers
+    AGS_AFR_TRANSFERENGINE_3D_ENGINE                        = 1,    ///< Use 3D engine for Crossfire API transfers
+    AGS_AFR_TRANSFERENGINE_COPY_ENGINE                      = 2,    ///< Use Copy engine for Crossfire API transfers
+} AGSAfrTransferEngine;
+
+///
+/// Function to create a Direct3D11 resource with the specified AFR transfer type and specified transfer engine.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] desc                                Pointer to the D3D11 resource description.
+/// \param [in] initialData                         Optional pointer to the initializing data for the resource.
+/// \param [out] buffer                             Returned pointer to the resource.
+/// \param [in] transferType                        The transfer behavior.
+/// \param [in] transferEngine                      The transfer engine to use.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateBuffer( AGSContext* context, const D3D11_BUFFER_DESC* desc, const D3D11_SUBRESOURCE_DATA* initialData, ID3D11Buffer** buffer, AGSAfrTransferType transferType, AGSAfrTransferEngine transferEngine );
+
+///
+/// Function to create a Direct3D11 resource with the specified AFR transfer type and specified transfer engine.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] desc                                Pointer to the D3D11 resource description.
+/// \param [in] initialData                         Optional pointer to the initializing data for the resource.
+/// \param [out] texture1D                          Returned pointer to the resource.
+/// \param [in] transferType                        The transfer behavior.
+/// \param [in] transferEngine                      The transfer engine to use.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateTexture1D( AGSContext* context, const D3D11_TEXTURE1D_DESC* desc, const D3D11_SUBRESOURCE_DATA* initialData, ID3D11Texture1D** texture1D, AGSAfrTransferType transferType, AGSAfrTransferEngine transferEngine );
+
+///
+/// Function to create a Direct3D11 resource with the specified AFR transfer type and specified transfer engine.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] desc                                Pointer to the D3D11 resource description.
+/// \param [in] initialData                         Optional pointer to the initializing data for the resource.
+/// \param [out] texture2D                          Returned pointer to the resource.
+/// \param [in] transferType                        The transfer behavior.
+/// \param [in] transferEngine                      The transfer engine to use.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateTexture2D( AGSContext* context, const D3D11_TEXTURE2D_DESC* desc, const D3D11_SUBRESOURCE_DATA* initialData, ID3D11Texture2D** texture2D, AGSAfrTransferType transferType, AGSAfrTransferEngine transferEngine );
+
+///
+/// Function to create a Direct3D11 resource with the specified AFR transfer type and specified transfer engine.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] desc                                Pointer to the D3D11 resource description.
+/// \param [in] initialData                         Optional pointer to the initializing data for the resource.
+/// \param [out] texture3D                          Returned pointer to the resource.
+/// \param [in] transferType                        The transfer behavior.
+/// \param [in] transferEngine                      The transfer engine to use.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_CreateTexture3D( AGSContext* context, const D3D11_TEXTURE3D_DESC* desc, const D3D11_SUBRESOURCE_DATA* initialData, ID3D11Texture3D** texture3D, AGSAfrTransferType transferType, AGSAfrTransferEngine transferEngine );
+
+///
+/// Function to notify the driver that we have finished writing to the resource this frame.
+/// This will initiate a transfer for AGS_AFR_TRANSFER_1STEP_P2P,
+/// AGS_AFR_TRANSFER_2STEP_NO_BROADCAST, and AGS_AFR_TRANSFER_2STEP_WITH_BROADCAST.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] resource                            Pointer to the resource.
+/// \param [in] transferRegions                     An array of transfer regions (can be null to specify the whole area).
+/// \param [in] subresourceArray                    An array of subresource indices (can be null to specify all subresources).
+/// \param [in] numSubresources                     The number of subresources in subresourceArray OR number of transferRegions. Use 0 to specify ALL subresources and one transferRegion (which may be null if specifying the whole area).
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_NotifyResourceEndWrites( AGSContext* context, ID3D11Resource* resource, const D3D11_RECT* transferRegions, const unsigned int* subresourceArray, unsigned int numSubresources );
+
+///
+/// This will notify the driver that the app will begin read/write access to the resource.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] resource                            Pointer to the resource.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_NotifyResourceBeginAllAccess( AGSContext* context, ID3D11Resource* resource );
+
+///
+/// This is used for AGS_AFR_TRANSFER_1STEP_P2P to notify when it is safe to initiate a transfer.
+/// This call in frame N-(NumGpus-1) allows a 1 step P2P in frame N to start.
+/// This should be called after agsDriverExtensionsDX11_NotifyResourceEndWrites.
+///
+/// \param [in] context                             Pointer to a context.
+/// \param [in] resource                            Pointer to the resource.
+///
+AMD_AGS_API AGSReturnCode agsDriverExtensionsDX11_NotifyResourceEndAllAccess( AGSContext* context, ID3D11Resource* resource );
+
+/// @}
+
+/// @}
+
+/// \defgroup typedefs Function pointer typedefs
+/// List of function pointer typedefs for the API
+/// @{
+
+typedef AMD_AGS_API AGSDriverVersionResult  (*AGS_CHECKDRIVERVERSION)( const char*, unsigned int ); ///< \ref agsCheckDriverVersion
+typedef AMD_AGS_API int                     (*AGS_GETVERSIONNUMBER)( void ); ///< \ref agsGetVersionNumber
+typedef AMD_AGS_API AGSReturnCode           (*AGS_INITIALIZE)( int, const AGSConfiguration*, AGSContext**, AGSGPUInfo_600* ); ///< \ref agsInitialize
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DEINITIALIZE)( AGSContext* ); ///< \ref agsDeInitialize
+typedef AMD_AGS_API AGSReturnCode           (*AGS_SETDISPLAYMODE)( AGSContext*, int, int, const AGSDisplaySettings* ); ///< \ref agsSetDisplayMode
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX12_CREATEDEVICE)( AGSContext*, const AGSDX12DeviceCreationParams*, const AGSDX12ExtensionParams*, AGSDX12ReturnedParams* ); ///< \ref agsDriverExtensionsDX12_CreateDevice
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX12_DESTROYDEVICE)( AGSContext*, ID3D12Device*, unsigned int* ); ///< \ref agsDriverExtensionsDX12_DestroyDevice
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX12_PUSHMARKER)( AGSContext*, ID3D12GraphicsCommandList*, const char* ); ///< \ref agsDriverExtensionsDX12_PushMarker
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX12_POPMARKER)( AGSContext*, ID3D12GraphicsCommandList* ); ///< \ref agsDriverExtensionsDX12_PopMarker
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX12_SETMARKER)( AGSContext*, ID3D12GraphicsCommandList*, const char* ); ///< \ref agsDriverExtensionsDX12_SetMarker
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_CREATEDEVICE)( AGSContext*, const AGSDX11DeviceCreationParams*, const AGSDX11ExtensionParams*, AGSDX11ReturnedParams* ); ///< \ref agsDriverExtensionsDX11_CreateDevice
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_DESTROYDEVICE)( AGSContext*, ID3D11Device*, unsigned int*, ID3D11DeviceContext*, unsigned int* ); ///< \ref agsDriverExtensionsDX11_DestroyDevice
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_WRITEBREADCRUMB)( AGSContext*, const AGSBreadcrumbMarker* ); ///< \ref agsDriverExtensionsDX11_WriteBreadcrumb
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_IASETPRIMITIVETOPOLOGY)( AGSContext*, enum D3D_PRIMITIVE_TOPOLOGY ); ///< \ref agsDriverExtensionsDX11_IASetPrimitiveTopology
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_BEGINUAVOVERLAP)( AGSContext*, ID3D11DeviceContext* ); ///< \ref agsDriverExtensionsDX11_BeginUAVOverlap
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_ENDUAVOVERLAP)( AGSContext*, ID3D11DeviceContext* ); ///< \ref agsDriverExtensionsDX11_EndUAVOverlap
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_SETDEPTHBOUNDS)( AGSContext*, ID3D11DeviceContext*, bool, float, float ); ///< \ref agsDriverExtensionsDX11_SetDepthBounds
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_MULTIDRAWINSTANCEDINDIRECT)( AGSContext*, ID3D11DeviceContext*, unsigned int, ID3D11Buffer*, unsigned int, unsigned int ); ///< \ref agsDriverExtensionsDX11_MultiDrawInstancedIndirect
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_MULTIDRAWINDEXEDINSTANCEDINDIRECT)( AGSContext*, ID3D11DeviceContext*, unsigned int, ID3D11Buffer*, unsigned int, unsigned int ); ///< \ref agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_MULTIDRAWINSTANCEDINDIRECTCOUNTINDIRECT)( AGSContext*, ID3D11DeviceContext*, ID3D11Buffer*, unsigned int, ID3D11Buffer*, unsigned int, unsigned int ); ///< \ref agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_MULTIDRAWINDEXEDINSTANCEDINDIRECTCOUNTINDIRECT)( AGSContext*, ID3D11DeviceContext*, ID3D11Buffer*, unsigned int, ID3D11Buffer*, unsigned int, unsigned int ); ///< \ref agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_SETMAXASYNCCOMPILETHREADCOUNT)( AGSContext*, unsigned int ); ///< \ref agsDriverExtensionsDX11_SetMaxAsyncCompileThreadCount
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_NUMPENDINGASYNCOMPILEJOBS)( AGSContext*, unsigned int* ); ///< \ref agsDriverExtensionsDX11_NumPendingAsyncCompileJobs
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_SETDISKSHADERCACHEENABLED)( AGSContext*, int ); ///< \ref agsDriverExtensionsDX11_SetDiskShaderCacheEnabled
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_SETVIEWBROADCASTMASKS)( AGSContext*, unsigned long long, unsigned long long, int ); ///< \ref agsDriverExtensionsDX11_SetViewBroadcastMasks
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_GETMAXCLIPRECTS)( AGSContext*, unsigned int* ); ///< \ref agsDriverExtensionsDX11_GetMaxClipRects
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_SETCLIPRECTS)( AGSContext*, unsigned int, const AGSClipRect* ); ///< \ref agsDriverExtensionsDX11_SetClipRects
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_CREATEBUFFER)( AGSContext*, const D3D11_BUFFER_DESC*, const D3D11_SUBRESOURCE_DATA*, ID3D11Buffer**, AGSAfrTransferType, AGSAfrTransferEngine ); ///< \ref agsDriverExtensionsDX11_CreateBuffer
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_CREATETEXTURE1D)( AGSContext*, const D3D11_TEXTURE1D_DESC*, const D3D11_SUBRESOURCE_DATA*, ID3D11Texture1D**, AGSAfrTransferType, AGSAfrTransferEngine ); ///< \ref agsDriverExtensionsDX11_CreateTexture1D
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_CREATETEXTURE2D)( AGSContext*, const D3D11_TEXTURE2D_DESC*, const D3D11_SUBRESOURCE_DATA*, ID3D11Texture2D**, AGSAfrTransferType, AGSAfrTransferEngine ); ///< \ref agsDriverExtensionsDX11_CreateTexture2D
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_CREATETEXTURE3D)( AGSContext*, const D3D11_TEXTURE3D_DESC*, const D3D11_SUBRESOURCE_DATA*, ID3D11Texture3D**, AGSAfrTransferType, AGSAfrTransferEngine ); ///< \ref agsDriverExtensionsDX11_CreateTexture3D
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_NOTIFYRESOURCEENDWRITES)( AGSContext*, ID3D11Resource*, const D3D11_RECT*, const unsigned int*, unsigned int ); ///< \ref agsDriverExtensionsDX11_NotifyResourceEndWrites
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_NOTIFYRESOURCEBEGINALLACCESS)( AGSContext*, ID3D11Resource* ); ///< \ref agsDriverExtensionsDX11_NotifyResourceBeginAllAccess
+typedef AMD_AGS_API AGSReturnCode           (*AGS_DRIVEREXTENSIONSDX11_NOTIFYRESOURCEENDALLACCESS)( AGSContext*, ID3D11Resource* ); ///< \ref agsDriverExtensionsDX11_NotifyResourceEndAllAccess
+/// @}
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // AMD_AGS_H
diff --git a/dlls/amd_ags_x64/amd_ags_x64.spec b/dlls/amd_ags_x64/amd_ags_x64.spec
new file mode 100644
index 0000000..d8126fa
--- /dev/null
+++ b/dlls/amd_ags_x64/amd_ags_x64.spec
@@ -0,0 +1,45 @@
+@ stdcall agsDeInit(ptr)
+@ stdcall agsDeInitialize(ptr)
+@ stdcall agsCheckDriverVersion(ptr long)
+@ stdcall -norelay -arch=win64 agsDriverExtensionsDX11_BeginUAVOverlap() DX11_BeginUAVOverlap_impl
+@ stub agsDriverExtensionsDX11_CreateBuffer
+@ stdcall agsDriverExtensionsDX11_CreateDevice(ptr ptr ptr ptr)
+@ stub agsDriverExtensionsDX11_CreateFromDevice
+@ stub agsDriverExtensionsDX11_CreateTexture1D
+@ stub agsDriverExtensionsDX11_CreateTexture2D
+@ stub agsDriverExtensionsDX11_CreateTexture3D
+@ stdcall agsDriverExtensionsDX11_DeInit(ptr)
+@ stub agsDriverExtensionsDX11_Destroy
+@ stdcall -norelay -arch=win64 agsDriverExtensionsDX11_DestroyDevice()
+@ stdcall -norelay -arch=win64 agsDriverExtensionsDX11_EndUAVOverlap() DX11_EndUAVOverlap_impl
+@ stub agsDriverExtensionsDX11_GetMaxClipRects
+@ stub agsDriverExtensionsDX11_IASetPrimitiveTopology
+@ stdcall agsDriverExtensionsDX11_Init(ptr ptr long ptr)
+@ stub agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirect
+@ stub agsDriverExtensionsDX11_MultiDrawIndexedInstancedIndirectCountIndirect
+@ stub agsDriverExtensionsDX11_MultiDrawInstancedIndirect
+@ stub agsDriverExtensionsDX11_MultiDrawInstancedIndirectCountIndirect
+@ stub agsDriverExtensionsDX11_NotifyResourceBeginAllAccess
+@ stub agsDriverExtensionsDX11_NotifyResourceEndAllAccess
+@ stub agsDriverExtensionsDX11_NotifyResourceEndWrites
+@ stub agsDriverExtensionsDX11_NumPendingAsyncCompileJobs
+@ stub agsDriverExtensionsDX11_SetClipRects
+@ stdcall -norelay -arch=win64 agsDriverExtensionsDX11_SetDepthBounds() DX11_SetDepthBounds_impl
+@ stub agsDriverExtensionsDX11_SetDiskShaderCacheEnabled
+@ stub agsDriverExtensionsDX11_SetMaxAsyncCompileThreadCount
+@ stub agsDriverExtensionsDX11_SetViewBroadcastMasks
+@ stub agsDriverExtensionsDX11_WriteBreadcrumb
+@ stdcall agsDriverExtensionsDX12_CreateDevice(ptr ptr ptr ptr)
+@ stub agsDriverExtensionsDX12_CreateFromDevice
+@ stub agsDriverExtensionsDX12_DeInit
+@ stub agsDriverExtensionsDX12_Destroy
+@ stdcall agsDriverExtensionsDX12_DestroyDevice(ptr ptr ptr)
+@ stub agsDriverExtensionsDX12_Init
+@ stub agsDriverExtensionsDX12_PopMarker
+@ stub agsDriverExtensionsDX12_PushMarker
+@ stub agsDriverExtensionsDX12_SetMarker
+@ stdcall agsGetCrossfireGPUCount(ptr ptr)
+@ stdcall agsGetVersionNumber()
+@ stdcall agsInit(ptr ptr ptr)
+@ stdcall agsInitialize(long ptr ptr ptr)
+@ stdcall agsSetDisplayMode(ptr long long ptr)
diff --git a/dlls/amd_ags_x64/amd_ags_x64_main.c b/dlls/amd_ags_x64/amd_ags_x64_main.c
new file mode 100644
index 0000000..9bd75ad
--- /dev/null
+++ b/dlls/amd_ags_x64/amd_ags_x64_main.c
@@ -0,0 +1,1424 @@
+#include <stdarg.h>
+#include <stdbool.h>
+#include <assert.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "wine/vulkan.h"
+#include "wine/asm.h"
+
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
+
+#include "dxgi1_6.h"
+
+#include "dxvk_interfaces.h"
+
+#include "amd_ags.h"
+
+#include "unixlib.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(amd_ags);
+
+#define AMD_AGS_CALL(func, args) WINE_UNIX_CALL( unix_ ## func, args )
+
+static INIT_ONCE unix_init_once = INIT_ONCE_STATIC_INIT;
+static BOOL unix_lib_initialized;
+
+static BOOL WINAPI init_unix_lib_once( INIT_ONCE *once, void *param, void **context )
+{
+    unix_lib_initialized = !__wine_init_unix_call() && !AMD_AGS_CALL( init, NULL );
+    return TRUE;
+}
+
+static BOOL init_unix_lib(void)
+{
+    InitOnceExecuteOnce( &unix_init_once, init_unix_lib_once, NULL, NULL );
+    return unix_lib_initialized;
+}
+
+static const char driver_version[] = "23.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition";
+static const char radeon_version[] = "23.10.2";
+
+enum amd_ags_version
+{
+    AMD_AGS_VERSION_5_0_5,
+    AMD_AGS_VERSION_5_1_1,
+    AMD_AGS_VERSION_5_2_0,
+    AMD_AGS_VERSION_5_3_0,
+    AMD_AGS_VERSION_5_4_0,
+    AMD_AGS_VERSION_5_4_1,
+    AMD_AGS_VERSION_5_4_2,
+    AMD_AGS_VERSION_6_0_0,
+    AMD_AGS_VERSION_6_1_0,
+
+    AMD_AGS_VERSION_COUNT
+};
+
+static const struct
+{
+    unsigned int ags_min_public_version;
+    unsigned int ags_max_public_version;
+    unsigned int device_size;
+    unsigned int dx11_returned_params_size;
+    int max_asicFamily;
+}
+amd_ags_info[AMD_AGS_VERSION_COUNT] =
+{
+    {AGS_MAKE_VERSION(5, 0, 0), AGS_MAKE_VERSION(5, 0, 6), sizeof(AGSDeviceInfo_511), sizeof(AGSDX11ReturnedParams_511), 0},
+    {AGS_MAKE_VERSION(5, 1, 1), AGS_MAKE_VERSION(5, 1, 1), sizeof(AGSDeviceInfo_511), sizeof(AGSDX11ReturnedParams_511), 0},
+    {AGS_MAKE_VERSION(5, 2, 0), AGS_MAKE_VERSION(5, 2, 1), sizeof(AGSDeviceInfo_520), sizeof(AGSDX11ReturnedParams_520), 0},
+    {AGS_MAKE_VERSION(5, 3, 0), AGS_MAKE_VERSION(5, 3, 0), sizeof(AGSDeviceInfo_520), sizeof(AGSDX11ReturnedParams_520), 0},
+    {AGS_MAKE_VERSION(5, 4, 0), AGS_MAKE_VERSION(5, 4, 0), sizeof(AGSDeviceInfo_540), sizeof(AGSDX11ReturnedParams_520), AsicFamily_RDNA},
+    {AGS_MAKE_VERSION(5, 4, 1), AGS_MAKE_VERSION(5, 4, 1), sizeof(AGSDeviceInfo_541), sizeof(AGSDX11ReturnedParams_520), AsicFamily_RDNA},
+    {AGS_MAKE_VERSION(5, 4, 2), AGS_MAKE_VERSION(5, 4, 2), sizeof(AGSDeviceInfo_542), sizeof(AGSDX11ReturnedParams_520), AsicFamily_RDNA},
+    {AGS_MAKE_VERSION(6, 0, 0), AGS_MAKE_VERSION(6, 0, 1), sizeof(AGSDeviceInfo_600), sizeof(AGSDX11ReturnedParams_600), AsicFamily_RDNA2},
+    {AGS_MAKE_VERSION(6, 1, 0), AGS_MAKE_VERSION(6, 2, 0), sizeof(AGSDeviceInfo_600), sizeof(AGSDX11ReturnedParams_600), AsicFamily_RDNA3},
+};
+
+#define DEF_FIELD(name) {DEVICE_FIELD_##name, {offsetof(AGSDeviceInfo_511, name), offsetof(AGSDeviceInfo_511, name), offsetof(AGSDeviceInfo_520, name), \
+        offsetof(AGSDeviceInfo_520, name), offsetof(AGSDeviceInfo_540, name), \
+        offsetof(AGSDeviceInfo_541, name), offsetof(AGSDeviceInfo_542, name), \
+        offsetof(AGSDeviceInfo_600, name), offsetof(AGSDeviceInfo_600, name)}}
+#define DEF_FIELD_520_BELOW(name) {DEVICE_FIELD_##name, {offsetof(AGSDeviceInfo_511, name), offsetof(AGSDeviceInfo_511, name), offsetof(AGSDeviceInfo_520, name), \
+        offsetof(AGSDeviceInfo_520, name), -1, \
+        -1, -1, -1, -1}}
+#define DEF_FIELD_520_UP(name) {DEVICE_FIELD_##name, {-1, -1, offsetof(AGSDeviceInfo_520, name), \
+        offsetof(AGSDeviceInfo_520, name), offsetof(AGSDeviceInfo_540, name), \
+        offsetof(AGSDeviceInfo_541, name), offsetof(AGSDeviceInfo_542, name), \
+        offsetof(AGSDeviceInfo_600, name), offsetof(AGSDeviceInfo_600, name)}}
+#define DEF_FIELD_540_UP(name) {DEVICE_FIELD_##name, {-1, -1, -1, \
+        -1, offsetof(AGSDeviceInfo_540, name), \
+        offsetof(AGSDeviceInfo_541, name), offsetof(AGSDeviceInfo_542, name), \
+        offsetof(AGSDeviceInfo_600, name), offsetof(AGSDeviceInfo_600, name)}}
+#define DEF_FIELD_540_600(name) {DEVICE_FIELD_##name, {-1, -1, -1, \
+        -1, offsetof(AGSDeviceInfo_540, name), \
+        offsetof(AGSDeviceInfo_541, name), offsetof(AGSDeviceInfo_542, name), \
+        -1, -1}}
+#define DEF_FIELD_600_BELOW(name) {DEVICE_FIELD_##name, {offsetof(AGSDeviceInfo_511, name), offsetof(AGSDeviceInfo_511, name), offsetof(AGSDeviceInfo_520, name), \
+        offsetof(AGSDeviceInfo_520, name), offsetof(AGSDeviceInfo_540, name), \
+        offsetof(AGSDeviceInfo_541, name), offsetof(AGSDeviceInfo_542, name), \
+        -1, -1}}
+
+#define DEVICE_FIELD_adapterString 0
+#define DEVICE_FIELD_architectureVersion 1
+#define DEVICE_FIELD_asicFamily 2
+#define DEVICE_FIELD_vendorId 3
+#define DEVICE_FIELD_deviceId 4
+#define DEVICE_FIELD_isPrimaryDevice 5
+#define DEVICE_FIELD_localMemoryInBytes 6
+#define DEVICE_FIELD_numDisplays 7
+#define DEVICE_FIELD_displays 8
+#define DEVICE_FIELD_isAPU 9
+
+#define DEVICE_FIELD_numCUs 10
+#define DEVICE_FIELD_coreClock 11
+#define DEVICE_FIELD_memoryClock 12
+#define DEVICE_FIELD_teraFlops 13
+#define DEVICE_FIELD_numWGPs 14
+#define DEVICE_FIELD_numROPs 15
+#define DEVICE_FIELD_memoryBandwidth 16
+
+static const struct
+{
+    unsigned int field_index;
+    int offset[AMD_AGS_VERSION_COUNT];
+}
+device_struct_fields[] =
+{
+    DEF_FIELD(adapterString),
+    DEF_FIELD_520_BELOW(architectureVersion),
+    DEF_FIELD_540_UP(asicFamily),
+    DEF_FIELD(vendorId),
+    DEF_FIELD(deviceId),
+    DEF_FIELD_600_BELOW(isPrimaryDevice),
+    DEF_FIELD(localMemoryInBytes),
+    DEF_FIELD(numDisplays),
+    DEF_FIELD(displays),
+    DEF_FIELD_540_600(isAPU),
+    DEF_FIELD(numCUs),
+    DEF_FIELD(coreClock),
+    DEF_FIELD(memoryClock),
+    DEF_FIELD(teraFlops),
+    DEF_FIELD_540_UP(numWGPs),
+    DEF_FIELD_520_UP(numROPs),
+    DEF_FIELD_520_UP(memoryBandwidth),
+};
+
+#undef DEF_FIELD
+
+#define GET_DEVICE_FIELD_ADDR(device, name, type, version) \
+        (device_struct_fields[DEVICE_FIELD_##name].offset[version] == -1 ? NULL \
+        : (type *)((BYTE *)device + device_struct_fields[DEVICE_FIELD_##name].offset[version]))
+
+#define SET_DEVICE_FIELD(device, name, type, version, value) { \
+        type *addr; \
+        if ((addr = GET_DEVICE_FIELD_ADDR(device, name, type, version))) \
+            *addr = value; \
+    }
+
+struct AGSContext
+{
+    enum amd_ags_version version;
+    unsigned int device_count;
+    struct AGSDeviceInfo *devices;
+    VkPhysicalDeviceProperties *properties;
+    VkPhysicalDeviceMemoryProperties *memory_properties;
+    ID3D11DeviceContext *d3d11_context;
+    AGSDX11ExtensionsSupported_600 extensions;
+    unsigned int public_version;
+};
+
+static HMODULE hd3d11, hd3d12;
+static typeof(D3D12CreateDevice) *pD3D12CreateDevice;
+static typeof(D3D11CreateDevice) *pD3D11CreateDevice;
+static typeof(D3D11CreateDeviceAndSwapChain) *pD3D11CreateDeviceAndSwapChain;
+
+#define AGS_VER_MAJOR(ver) ((ver) >> 22)
+#define AGS_VER_MINOR(ver) (((ver) >> 12) & ((1 << 10) - 1))
+#define AGS_VER_PATCH(ver) ((ver) & ((1 << 12) - 1))
+
+static const char *debugstr_agsversion(unsigned int ags_version)
+{
+    return wine_dbg_sprintf("%d.%d.%d", AGS_VER_MAJOR(ags_version), AGS_VER_MINOR(ags_version), AGS_VER_PATCH(ags_version));
+}
+
+static BOOL load_d3d12_functions(void)
+{
+    if (hd3d12)
+        return TRUE;
+
+    if (!(hd3d12 = LoadLibraryA("d3d12.dll")))
+        return FALSE;
+
+    pD3D12CreateDevice = (void *)GetProcAddress(hd3d12, "D3D12CreateDevice");
+    return TRUE;
+}
+
+static BOOL load_d3d11_functions(void)
+{
+    if (hd3d11)
+        return TRUE;
+
+    if (!(hd3d11 = LoadLibraryA("d3d11.dll")))
+        return FALSE;
+
+    pD3D11CreateDevice = (void *)GetProcAddress(hd3d11, "D3D11CreateDevice");
+    pD3D11CreateDeviceAndSwapChain = (void *)GetProcAddress(hd3d11, "D3D11CreateDeviceAndSwapChain");
+    return TRUE;
+}
+
+static AGSReturnCode vk_get_physical_device_properties(unsigned int *out_count,
+        VkPhysicalDeviceProperties **out, VkPhysicalDeviceMemoryProperties **out_memory)
+{
+    VkPhysicalDeviceProperties *properties = NULL;
+    VkPhysicalDeviceMemoryProperties *memory_properties = NULL;
+    VkPhysicalDevice *vk_physical_devices = NULL;
+    VkInstance vk_instance = VK_NULL_HANDLE;
+    VkInstanceCreateInfo create_info;
+    AGSReturnCode ret = AGS_SUCCESS;
+    uint32_t count, i;
+    VkResult vr;
+
+    *out = NULL;
+    *out_count = 0;
+
+    memset(&create_info, 0, sizeof(create_info));
+    create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
+    if ((vr = vkCreateInstance(&create_info, NULL, &vk_instance) < 0))
+    {
+        WARN("Failed to create Vulkan instance, vr %d.\n", vr);
+        goto done;
+    }
+
+    if ((vr = vkEnumeratePhysicalDevices(vk_instance, &count, NULL)) < 0)
+    {
+        WARN("Failed to enumerate devices, vr %d.\n", vr);
+        goto done;
+    }
+
+    if (!(vk_physical_devices = heap_calloc(count, sizeof(*vk_physical_devices))))
+    {
+        WARN("Failed to allocate memory.\n");
+        ret = AGS_OUT_OF_MEMORY;
+        goto done;
+    }
+
+    if ((vr = vkEnumeratePhysicalDevices(vk_instance, &count, vk_physical_devices)) < 0)
+    {
+        WARN("Failed to enumerate devices, vr %d.\n", vr);
+        goto done;
+    }
+
+    if (!(properties = heap_calloc(count, sizeof(*properties))))
+    {
+        WARN("Failed to allocate memory.\n");
+        ret = AGS_OUT_OF_MEMORY;
+        goto done;
+    }
+
+    if (!(memory_properties = heap_calloc(count, sizeof(*memory_properties))))
+    {
+        WARN("Failed to allocate memory.\n");
+        heap_free(properties);
+        ret = AGS_OUT_OF_MEMORY;
+        goto done;
+    }
+
+    for (i = 0; i < count; ++i)
+    {
+        vkGetPhysicalDeviceProperties(vk_physical_devices[i], &properties[i]);
+        if (properties[i].deviceType != VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU
+                && properties[i].deviceType != VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU)
+        {
+            TRACE("Skipping device type %d.\n", properties[i].deviceType);
+            --i;
+            --count;
+            continue;
+        }
+        vkGetPhysicalDeviceMemoryProperties(vk_physical_devices[i], &memory_properties[i]);
+    }
+
+    *out_count = count;
+    *out = properties;
+    *out_memory = memory_properties;
+
+done:
+    heap_free(vk_physical_devices);
+    if (vk_instance)
+        vkDestroyInstance(vk_instance, NULL);
+    return ret;
+}
+
+static enum amd_ags_version get_version_number(int ags_version)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(amd_ags_info); i++)
+        if (ags_version >= amd_ags_info[i].ags_min_public_version && ags_version <= amd_ags_info[i].ags_max_public_version)
+        {
+            TRACE("Found AGS v%s (internal %d).\n", debugstr_agsversion(ags_version), i);
+            return i;
+        }
+    ERR("Unknown ags_version %s, using 5.4.1.\n", debugstr_agsversion(ags_version));
+    return AMD_AGS_VERSION_5_4_1;
+}
+
+static BOOL get_ags_version_from_resource(const WCHAR *filename, enum amd_ags_version *ret, int *public_version)
+{
+    DWORD infosize;
+    void *infobuf;
+    void *val;
+    UINT vallen;
+    VS_FIXEDFILEINFO *info;
+    UINT16 major, minor, patch;
+
+    infosize = GetFileVersionInfoSizeW(filename, NULL);
+    if (!infosize)
+    {
+        ERR("File version info not found, err %u.\n", GetLastError());
+        return FALSE;
+    }
+
+    if (!(infobuf = heap_alloc(infosize)))
+    {
+        ERR("Failed to allocate memory.\n");
+        return FALSE;
+    }
+
+    if (!GetFileVersionInfoW(filename, 0, infosize, infobuf))
+    {
+        ERR("GetFileVersionInfoW failed, err %u.\n", GetLastError());
+        heap_free(infobuf);
+        return FALSE;
+    }
+
+    if (!VerQueryValueW(infobuf, L"\\", &val, &vallen) || (vallen != sizeof(VS_FIXEDFILEINFO)))
+    {
+        ERR("Version value not found, err %u.\n", GetLastError());
+        heap_free(infobuf);
+        return FALSE;
+    }
+
+    info = val;
+    major = info->dwFileVersionMS >> 16;
+    minor = info->dwFileVersionMS;
+    patch = info->dwFileVersionLS >> 16;
+    *public_version = AGS_MAKE_VERSION(major, minor, patch);
+    TRACE("Found amd_ags_x64.dll v%d.%d.%d\n", major, minor, patch);
+    *ret = get_version_number(*public_version);
+    heap_free(infobuf);
+    return TRUE;
+}
+
+static enum amd_ags_version guess_version_from_exports(HMODULE hnative)
+{
+    /* Known DLL versions without version info:
+     *  - An update to AGS 5.4.1 included an amd_ags_x64.dll with no file version info;
+     *  - CoD: Modern Warfare Remastered (2017) ships dll without version info which is version 5.0.1
+     *    (not tagged in AGSSDK history), compatible with 5.0.5.
+     */
+    if (GetProcAddress(hnative, "agsDriverExtensionsDX11_Init"))
+    {
+        /* agsDriverExtensionsDX11_Init was deprecated in 5.3.0 */
+        TRACE("agsDriverExtensionsDX11_Init found.\n");
+        return AMD_AGS_VERSION_5_0_5;
+    }
+    TRACE("Returning 5.4.1.\n");
+    return AMD_AGS_VERSION_5_4_1;
+}
+
+static enum amd_ags_version determine_ags_version(int *ags_version)
+{
+    /* AMD AGS is not binary compatible between versions (even minor versions), and the game
+     * does not request a specific version when calling agsInit().
+     * Checking the version of amd_ags_x64.dll shipped with the game is the only way to
+     * determine what version the game was built against.
+     */
+    enum amd_ags_version ret = AMD_AGS_VERSION_5_4_1;
+    WCHAR dllname[MAX_PATH], temp_path[MAX_PATH], temp_name[MAX_PATH];
+    int (WINAPI *pagsGetVersionNumber)(void);
+    HMODULE hnative = NULL;
+    DWORD size;
+
+    TRACE("*ags_version %#x.\n", *ags_version);
+
+    if (*ags_version)
+        return get_version_number(*ags_version);
+
+    *temp_name = 0;
+    if (!(size = GetModuleFileNameW(GetModuleHandleW(L"amd_ags_x64.dll"), dllname, ARRAY_SIZE(dllname)))
+            || size == ARRAY_SIZE(dllname))
+    {
+        ERR("GetModuleFileNameW failed.\n");
+        goto done;
+    }
+    if (!GetTempPathW(MAX_PATH, temp_path) || !GetTempFileNameW(temp_path, L"tmp", 0, temp_name))
+    {
+        ERR("Failed getting temp file name.\n");
+        goto done;
+    }
+    if (!CopyFileW(dllname, temp_name, FALSE))
+    {
+        ERR("Failed to copy file.\n");
+        goto done;
+    }
+
+    if (get_ags_version_from_resource(temp_name, &ret, ags_version))
+        goto done;
+
+    if (!(hnative = LoadLibraryW(temp_name)))
+    {
+        ERR("LoadLibraryW failed for %s.\n", debugstr_w(temp_name));
+        goto done;
+    }
+
+    if ((pagsGetVersionNumber = (void *)GetProcAddress(hnative, "agsGetVersionNumber")))
+    {
+        *ags_version = pagsGetVersionNumber();
+        ret = get_version_number(*ags_version);
+        TRACE("Got version %s (%d) from agsGetVersionNumber.\n", debugstr_agsversion(*ags_version), ret);
+        goto done;
+    }
+
+    ret = guess_version_from_exports(hnative);
+
+done:
+    if (!*ags_version)
+        *ags_version = amd_ags_info[ret].ags_max_public_version;
+
+    if (hnative)
+        FreeLibrary(hnative);
+
+    if (*temp_name)
+        DeleteFileW(temp_name);
+
+    TRACE("Using AGS v%s (internal %d) interface\n", debugstr_agsversion(*ags_version), ret);
+    return ret;
+}
+
+struct monitor_enum_context_600
+{
+    const char *adapter_name;
+    AGSDisplayInfo_600 **ret_displays;
+    int *ret_display_count;
+    IDXGIFactory1 *dxgi_factory;
+};
+
+static void create_dxgi_factory(HMODULE *hdxgi, IDXGIFactory1 **factory)
+{
+    typeof(CreateDXGIFactory1) *pCreateDXGIFactory1;
+
+    *factory = NULL;
+
+    if (!(*hdxgi = LoadLibraryW(L"dxgi.dll")))
+    {
+        ERR("Could not load dxgi.dll.\n");
+        return;
+    }
+
+    if (!(pCreateDXGIFactory1 = (void *)GetProcAddress(*hdxgi, "CreateDXGIFactory1")))
+    {
+        ERR("Could not find CreateDXGIFactory1.\n");
+        return;
+    }
+
+    if (FAILED(pCreateDXGIFactory1(&IID_IDXGIFactory1, (void**)factory)))
+        return;
+}
+
+static void release_dxgi_factory(HMODULE hdxgi, IDXGIFactory1 *factory)
+{
+    if (factory)
+        IDXGIFactory1_Release(factory);
+    if (hdxgi)
+        FreeLibrary(hdxgi);
+}
+
+static void fill_chroma_info(AGSDisplayInfo_600 *info, struct monitor_enum_context_600 *c, HMONITOR monitor)
+{
+    DXGI_OUTPUT_DESC1 output_desc;
+    IDXGIAdapter1 *adapter;
+    IDXGIOutput6 *output6;
+    IDXGIOutput *output;
+    BOOL found = FALSE;
+    unsigned int i, j;
+    HRESULT hr;
+
+    i = 0;
+    while (!found && (SUCCEEDED(IDXGIFactory1_EnumAdapters1(c->dxgi_factory, i++, &adapter))))
+    {
+        j = 0;
+        while (SUCCEEDED(IDXGIAdapter1_EnumOutputs(adapter, j++, &output)))
+        {
+            hr = IDXGIOutput_QueryInterface(output, &IID_IDXGIOutput6, (void**)&output6);
+            IDXGIOutput_Release(output);
+            if (FAILED(hr))
+            {
+                WARN("Failed to query IDXGIOutput6.\n");
+                continue;
+            }
+            hr = IDXGIOutput6_GetDesc1(output6, &output_desc);
+            IDXGIOutput6_Release(output6);
+
+            if (FAILED(hr) || output_desc.Monitor != monitor)
+                continue;
+            found = TRUE;
+
+            TRACE("output_desc.ColorSpace %#x.\n", output_desc.ColorSpace);
+            if (output_desc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020)
+            {
+                TRACE("Reporting monitor %s as HDR10 supported.\n", debugstr_a(info->displayDeviceName));
+                info->HDR10 = 1;
+            }
+
+            info->chromaticityRedX = output_desc.RedPrimary[0];
+            info->chromaticityRedY = output_desc.RedPrimary[1];
+            info->chromaticityGreenX = output_desc.GreenPrimary[0];
+            info->chromaticityGreenY = output_desc.GreenPrimary[1];
+            info->chromaticityBlueX = output_desc.BluePrimary[0];
+            info->chromaticityBlueY = output_desc.BluePrimary[1];
+            info->chromaticityWhitePointX = output_desc.WhitePoint[0];
+            info->chromaticityWhitePointY = output_desc.WhitePoint[1];
+
+            TRACE("chromacity: (%.6lf, %.6lf) (%.6lf, %.6lf) (%.6lf, %.6lf).\n", info->chromaticityRedX,
+                    info->chromaticityRedY, info->chromaticityGreenX, info->chromaticityGreenY, info->chromaticityBlueX,
+                    info->chromaticityBlueY);
+
+            info->screenDiffuseReflectance = 0;
+            info->screenSpecularReflectance = 0;
+
+            info->minLuminance = output_desc.MinLuminance;
+            info->maxLuminance = output_desc.MaxLuminance;
+            info->avgLuminance = output_desc.MaxFullFrameLuminance;
+        }
+        IDXGIAdapter1_Release(adapter);
+    }
+
+    if (!found)
+        WARN("dxgi output not found.\n");
+}
+
+static BOOL WINAPI monitor_enum_proc_600(HMONITOR hmonitor, HDC hdc, RECT *rect, LPARAM context)
+{
+    struct monitor_enum_context_600 *c = (struct monitor_enum_context_600 *)context;
+    MONITORINFOEXA monitor_info;
+    AGSDisplayInfo_600 *new_alloc;
+    DISPLAY_DEVICEA device;
+    AGSDisplayInfo_600 *info;
+    unsigned int i, mode;
+    DEVMODEA dev_mode;
+
+
+    monitor_info.cbSize = sizeof(monitor_info);
+    GetMonitorInfoA(hmonitor, (MONITORINFO *)&monitor_info);
+    TRACE("monitor_info.szDevice %s.\n", debugstr_a(monitor_info.szDevice));
+
+    device.cb = sizeof(device);
+    i = 0;
+    while (EnumDisplayDevicesA(NULL, i, &device, 0))
+    {
+        TRACE("device.DeviceName %s, device.DeviceString %s.\n", debugstr_a(device.DeviceName), debugstr_a(device.DeviceString));
+        ++i;
+        if (strcmp(device.DeviceString, c->adapter_name) || strcmp(device.DeviceName, monitor_info.szDevice))
+            continue;
+
+        if (*c->ret_display_count)
+        {
+            if (!(new_alloc = heap_realloc(*c->ret_displays, sizeof(*new_alloc) * (*c->ret_display_count + 1))))
+            {
+                ERR("No memory.");
+                return FALSE;
+            }
+            *c->ret_displays = new_alloc;
+        }
+        else if (!(*c->ret_displays = heap_alloc(sizeof(**c->ret_displays))))
+        {
+            ERR("No memory.");
+            return FALSE;
+        }
+        info = &(*c->ret_displays)[*c->ret_display_count];
+        memset(info, 0, sizeof(*info));
+        strcpy(info->displayDeviceName, device.DeviceName);
+        if (EnumDisplayDevicesA(info->displayDeviceName, 0, &device, 0))
+        {
+            strcpy(info->name, device.DeviceString);
+        }
+        else
+        {
+            ERR("Could not get monitor name for device %s.\n", debugstr_a(info->displayDeviceName));
+            strcpy(info->name, "Unknown");
+        }
+        if (monitor_info.dwFlags & MONITORINFOF_PRIMARY)
+            info->isPrimaryDisplay = 1;
+
+        mode = 0;
+        memset(&dev_mode, 0, sizeof(dev_mode));
+        dev_mode.dmSize = sizeof(dev_mode);
+        while (EnumDisplaySettingsExA(monitor_info.szDevice, mode, &dev_mode, EDS_RAWMODE))
+        {
+            ++mode;
+            if (dev_mode.dmPelsWidth > info->maxResolutionX)
+                info->maxResolutionX = dev_mode.dmPelsWidth;
+            if (dev_mode.dmPelsHeight > info->maxResolutionY)
+                info->maxResolutionY = dev_mode.dmPelsHeight;
+            if (dev_mode.dmDisplayFrequency > info->maxRefreshRate)
+                info->maxRefreshRate = dev_mode.dmDisplayFrequency;
+            memset(&dev_mode, 0, sizeof(dev_mode));
+            dev_mode.dmSize = sizeof(dev_mode);
+        }
+
+        info->eyefinityGridCoordX = -1;
+        info->eyefinityGridCoordY = -1;
+
+        info->currentResolution.offsetX = monitor_info.rcMonitor.left;
+        info->currentResolution.offsetY = monitor_info.rcMonitor.top;
+        info->currentResolution.width = monitor_info.rcMonitor.right - monitor_info.rcMonitor.left;
+        info->currentResolution.height = monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top;
+        info->visibleResolution = info->currentResolution;
+
+        memset(&dev_mode, 0, sizeof(dev_mode));
+        dev_mode.dmSize = sizeof(dev_mode);
+
+        if (EnumDisplaySettingsExA(monitor_info.szDevice, ENUM_CURRENT_SETTINGS, &dev_mode, EDS_RAWMODE))
+            info->currentRefreshRate = dev_mode.dmDisplayFrequency;
+        else
+            ERR("Could not get current display settings.\n");
+
+        fill_chroma_info(info, c, hmonitor);
+
+        ++*c->ret_display_count;
+
+        TRACE("Added display %s for %s.\n", debugstr_a(monitor_info.szDevice), debugstr_a(c->adapter_name));
+    }
+
+    return TRUE;
+}
+
+static void init_device_displays_600(const char *adapter_name, AGSDisplayInfo_600 **ret_displays, int *ret_display_count)
+{
+    struct monitor_enum_context_600 context;
+    HMODULE hdxgi;
+
+    TRACE("adapter_name %s.\n", debugstr_a(adapter_name));
+
+    context.adapter_name = adapter_name;
+    context.ret_displays = ret_displays;
+    context.ret_display_count = ret_display_count;
+    create_dxgi_factory(&hdxgi, &context.dxgi_factory);
+
+    EnumDisplayMonitors(NULL, NULL, monitor_enum_proc_600, (LPARAM)&context);
+    release_dxgi_factory(hdxgi, context.dxgi_factory);
+}
+
+static void init_device_displays_511(const char *adapter_name, AGSDisplayInfo_511 **ret_displays, int *ret_display_count)
+{
+    AGSDisplayInfo_600 *displays = NULL;
+    int display_count = 0;
+    int i;
+    *ret_displays = NULL;
+    *ret_display_count = 0;
+
+    init_device_displays_600(adapter_name, &displays, &display_count);
+
+    if ((*ret_displays = heap_alloc(sizeof(**ret_displays) * display_count)))
+    {
+        for (i = 0; i < display_count; i++)
+        {
+            memcpy(&(*ret_displays)[i], &displays[i], sizeof(AGSDisplayInfo_511));
+        }
+        *ret_display_count = display_count;
+    }
+
+    heap_free(displays);
+}
+
+
+static AGSReturnCode init_ags_context(AGSContext *context, int ags_version)
+{
+    AGSReturnCode ret;
+    unsigned int i, j;
+    BYTE *device;
+
+    memset(context, 0, sizeof(*context));
+
+    context->version = determine_ags_version(&ags_version);
+    context->public_version = ags_version;
+
+    ret = vk_get_physical_device_properties(&context->device_count, &context->properties, &context->memory_properties);
+    if (ret != AGS_SUCCESS || !context->device_count)
+        return ret;
+
+    assert(context->version < AMD_AGS_VERSION_COUNT);
+
+    if (!(context->devices = heap_calloc(context->device_count, amd_ags_info[context->version].device_size)))
+    {
+        WARN("Failed to allocate memory.\n");
+        heap_free(context->properties);
+        heap_free(context->memory_properties);
+        return AGS_OUT_OF_MEMORY;
+    }
+
+    device = (BYTE *)context->devices;
+    for (i = 0; i < context->device_count; ++i)
+    {
+        const VkPhysicalDeviceProperties *vk_properties = &context->properties[i];
+        const VkPhysicalDeviceMemoryProperties *vk_memory_properties = &context->memory_properties[i];
+        struct AGSDeviceInfo_600 *device_600 = (struct AGSDeviceInfo_600 *)device;
+        VkDeviceSize local_memory_size = 0;
+
+        for (j = 0; j < vk_memory_properties->memoryHeapCount; j++)
+        {
+            if (vk_memory_properties->memoryHeaps[j].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
+            {
+                local_memory_size = vk_memory_properties->memoryHeaps[j].size;
+                break;
+            }
+        }
+
+        TRACE("device %s, type %d, %04x:%04x, reporting local memory size 0x%s bytes\n",
+                debugstr_a(vk_properties->deviceName), vk_properties->deviceType,
+                vk_properties->vendorID, vk_properties->deviceID, wine_dbgstr_longlong(local_memory_size));
+
+        SET_DEVICE_FIELD(device, adapterString, const char *, context->version, vk_properties->deviceName);
+        SET_DEVICE_FIELD(device, vendorId, int, context->version, vk_properties->vendorID);
+        SET_DEVICE_FIELD(device, deviceId, int, context->version, vk_properties->deviceID);
+        if (vk_properties->vendorID == 0x1002)
+        {
+            struct get_device_info_params params =
+            {
+                .device_id = vk_properties->deviceID,
+            };
+
+            SET_DEVICE_FIELD(device, architectureVersion, ArchitectureVersion, context->version, ArchitectureVersion_GCN);
+            if (init_unix_lib() && !AMD_AGS_CALL(get_device_info, &params))
+            {
+                SET_DEVICE_FIELD(device, asicFamily, AsicFamily, context->version,
+                        min(params.asic_family, amd_ags_info[context->version].max_asicFamily));
+                SET_DEVICE_FIELD(device, numCUs, int, context->version, params.num_cu);
+                SET_DEVICE_FIELD(device, numWGPs, int, context->version, params.num_wgp);
+                SET_DEVICE_FIELD(device, numROPs, int, context->version, params.num_rops);
+                SET_DEVICE_FIELD(device, coreClock, int, context->version, params.core_clock);
+                SET_DEVICE_FIELD(device, memoryClock, int, context->version, params.memory_clock);
+                SET_DEVICE_FIELD(device, memoryBandwidth, int, context->version, params.memory_bandwidth);
+                SET_DEVICE_FIELD(device, teraFlops, float, context->version, params.teraflops);
+            }
+            else
+            {
+                SET_DEVICE_FIELD(device, asicFamily, AsicFamily, context->version, AsicFamily_GCN4);
+            }
+            if (vk_properties->deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU)
+            {
+                if (context->version >= AMD_AGS_VERSION_6_0_0)
+                    device_600->isAPU = 1;
+                else
+                    SET_DEVICE_FIELD(device, isAPU, int, context->version, 1);
+            }
+        }
+        SET_DEVICE_FIELD(device, localMemoryInBytes, ULONG64, context->version, local_memory_size);
+        if (!i)
+        {
+            if (context->version >= AMD_AGS_VERSION_6_0_0)
+            {
+                // This is a bitfield now... Nice...
+                device_600->isPrimaryDevice = 1;
+            }
+            else
+            {
+                SET_DEVICE_FIELD(device, isPrimaryDevice, int, context->version, 1);
+            }   
+        }
+
+        if (context->version >= AMD_AGS_VERSION_6_0_0)
+        {
+            init_device_displays_600(vk_properties->deviceName,
+                    GET_DEVICE_FIELD_ADDR(device, displays, AGSDisplayInfo_600 *, context->version),
+                    GET_DEVICE_FIELD_ADDR(device, numDisplays, int, context->version));
+        }
+        else
+        {
+            init_device_displays_511(vk_properties->deviceName,
+                    GET_DEVICE_FIELD_ADDR(device, displays, AGSDisplayInfo_511 *, context->version),
+                    GET_DEVICE_FIELD_ADDR(device, numDisplays, int, context->version));
+        }
+
+        device += amd_ags_info[context->version].device_size;
+    }
+
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsInit(AGSContext **context, const AGSConfiguration *config, AGSGPUInfo_511 *gpu_info)
+{
+    struct AGSContext *object;
+    AGSReturnCode ret;
+
+    TRACE("context %p, config %p, gpu_info %p.\n", context, config, gpu_info);
+
+    if (!context || !gpu_info)
+        return AGS_INVALID_ARGS;
+
+    if (config)
+        FIXME("Ignoring config %p.\n", config);
+
+    if (!(object = heap_alloc(sizeof(*object))))
+        return AGS_OUT_OF_MEMORY;
+
+    if ((ret = init_ags_context(object, 0)) != AGS_SUCCESS)
+    {
+        heap_free(object);
+        return ret;
+    }
+
+    memset(gpu_info, 0, sizeof(*gpu_info));
+    gpu_info->agsVersionMajor = AGS_VER_MAJOR(object->public_version);
+    gpu_info->agsVersionMinor = AGS_VER_MINOR(object->public_version);
+    gpu_info->agsVersionPatch = AGS_VER_PATCH(object->public_version);
+    gpu_info->driverVersion = driver_version;
+    gpu_info->radeonSoftwareVersion  = radeon_version;
+    gpu_info->numDevices = object->device_count;
+    gpu_info->devices = object->devices;
+
+    TRACE("Created context %p.\n", object);
+
+    *context = object;
+
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsInitialize(int ags_version, const AGSConfiguration *config, AGSContext **context, AGSGPUInfo_600 *gpu_info)
+{
+    struct AGSContext *object;
+    AGSReturnCode ret;
+
+    TRACE("ags_verison %d, context %p, config %p, gpu_info %p.\n", ags_version, context, config, gpu_info);
+
+    if (!context || !gpu_info)
+        return AGS_INVALID_ARGS;
+
+    if (config)
+        FIXME("Ignoring config %p.\n", config);
+
+    if (!(object = heap_alloc(sizeof(*object))))
+        return AGS_OUT_OF_MEMORY;
+
+    if ((ret = init_ags_context(object, ags_version)) != AGS_SUCCESS)
+    {
+        heap_free(object);
+        return ret;
+    }
+
+    memset(gpu_info, 0, sizeof(*gpu_info));
+    gpu_info->driverVersion = driver_version;
+    gpu_info->radeonSoftwareVersion  = radeon_version;
+    gpu_info->numDevices = object->device_count;
+    gpu_info->devices = object->devices;
+
+    TRACE("Created context %p.\n", object);
+
+    *context = object;
+
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDeInit(AGSContext *context)
+{
+    return agsDeInitialize(context);
+}
+
+AGSReturnCode WINAPI agsDeInitialize(AGSContext *context)
+{
+    unsigned int i;
+    BYTE *device;
+
+    TRACE("context %p.\n", context);
+
+    if (!context)
+        return AGS_SUCCESS;
+
+    if (context->d3d11_context)
+    {
+        ID3D11DeviceContext_Release(context->d3d11_context);
+        context->d3d11_context = NULL;
+    }
+    heap_free(context->memory_properties);
+    heap_free(context->properties);
+    device = (BYTE *)context->devices;
+    for (i = 0; i < context->device_count; ++i)
+    {
+        heap_free(*GET_DEVICE_FIELD_ADDR(device, displays, void *, context->version));
+        device += amd_ags_info[context->version].device_size;
+    }
+    heap_free(context->devices);
+    heap_free(context);
+
+    return AGS_SUCCESS;
+}
+
+static DXGI_COLOR_SPACE_TYPE convert_ags_colorspace_506(AGSDisplaySettings_Mode_506 mode)
+{
+    switch (mode)
+    {
+        default:
+            ERR("Unknown color space in AGS: %d.\n", mode);
+        /* fallthrough */
+        case Mode_506_SDR:
+            TRACE("Setting Mode_506_SDR.\n");
+            return DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
+        case Mode_506_PQ:
+            TRACE("Setting Mode_506_PQ.\n");
+            return DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+        case Mode_506_scRGB:
+            TRACE("Setting Mode_506_scRGB.\n");
+            return DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+    }
+}
+
+static DXGI_COLOR_SPACE_TYPE convert_ags_colorspace_600(AGSDisplaySettings_Mode_600 mode)
+{
+    switch (mode)
+    {
+        default:
+            ERR("Unknown color space in AGS: %d\n", mode);
+        /* fallthrough */
+        case Mode_600_SDR:
+            TRACE("Setting Mode_600_SDR.\n");
+            return DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
+        case Mode_600_HDR10_PQ:
+            TRACE("Setting Mode_600_HDR10_PQ.\n");
+            return DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+        case Mode_600_HDR10_scRGB:
+            TRACE("Setting Mode_600_HDR10_scRGB.\n");
+            return DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+    }
+}
+
+static DXGI_HDR_METADATA_HDR10 convert_ags_metadata(const AGSDisplaySettings_600 *settings)
+{
+    DXGI_HDR_METADATA_HDR10 metadata;
+    metadata.RedPrimary[0] = settings->chromaticityRedX * 50000;
+    metadata.RedPrimary[1] = settings->chromaticityRedY * 50000;
+    metadata.GreenPrimary[0] = settings->chromaticityGreenX * 50000;
+    metadata.GreenPrimary[1] = settings->chromaticityGreenY * 50000;
+    metadata.BluePrimary[0] = settings->chromaticityBlueX * 50000;
+    metadata.BluePrimary[1] = settings->chromaticityBlueY * 50000;
+    metadata.WhitePoint[0] = settings->chromaticityWhitePointX * 50000;
+    metadata.WhitePoint[1] = settings->chromaticityWhitePointY * 50000;
+    metadata.MaxMasteringLuminance = settings->maxLuminance;
+    metadata.MinMasteringLuminance = settings->minLuminance / 0.0001f;
+    metadata.MaxContentLightLevel = settings->maxContentLightLevel;
+    metadata.MaxFrameAverageLightLevel = settings->maxFrameAverageLightLevel;
+    return metadata;
+}
+
+AGSReturnCode WINAPI agsSetDisplayMode(AGSContext *context, int device_index, int display_index, const AGSDisplaySettings *settings)
+{
+    const AGSDisplaySettings_506 *settings506 = &settings->agsDisplaySettings506;
+    const AGSDisplaySettings_600 *settings600 = &settings->agsDisplaySettings600;
+    IDXGIVkInteropFactory1 *dxgi_interop = NULL;
+    DXGI_COLOR_SPACE_TYPE colorspace;
+    DXGI_HDR_METADATA_HDR10 metadata;
+    AGSReturnCode ret = AGS_SUCCESS;
+    IDXGIFactory1 *dxgi_factory;
+    HMODULE hdxgi;
+
+    TRACE("context %p device_index %d display_index %d settings %p\n", context, device_index,
+          display_index, settings);
+
+    if (!context)
+        return AGS_INVALID_ARGS;
+
+    create_dxgi_factory(&hdxgi, &dxgi_factory);
+    if (!dxgi_factory)
+        goto done;
+
+    if (FAILED(IDXGIFactory1_QueryInterface(dxgi_factory, &IID_IDXGIVkInteropFactory1, (void**)&dxgi_interop)))
+    {
+        WARN("Failed to get IDXGIVkInteropFactory1.\n");
+        goto done;
+    }
+
+    colorspace = context->version < AMD_AGS_VERSION_5_1_1
+        ? convert_ags_colorspace_506(settings506->mode)
+        : convert_ags_colorspace_600(settings600->mode);
+    /* Settings 506, 511 and 600 are identical aside from enum order + use
+     * of bitfield flags we do not use. */
+    metadata = convert_ags_metadata(settings600);
+
+    TRACE("chromacity: (%.6lf, %.6lf) (%.6lf, %.6lf) (%.6lf, %.6lf).\n", settings600->chromaticityRedX,
+            settings600->chromaticityRedY, settings600->chromaticityGreenX, settings600->chromaticityGreenY,
+            settings600->chromaticityBlueX, settings600->chromaticityBlueY);
+
+    if (FAILED(IDXGIVkInteropFactory1_SetGlobalHDRState(dxgi_interop, colorspace, &metadata)))
+        ret = AGS_DX_FAILURE;
+
+done:
+    if (dxgi_interop)
+        IDXGIVkInteropFactory1_Release(dxgi_interop);
+    release_dxgi_factory(hdxgi, dxgi_factory);
+    return ret;
+}
+
+AGSReturnCode WINAPI agsGetCrossfireGPUCount(AGSContext *context, int *gpu_count)
+{
+    TRACE("context %p gpu_count %p stub!\n", context, gpu_count);
+
+    if (!context || !gpu_count)
+        return AGS_INVALID_ARGS;
+
+    *gpu_count = 1;
+    return AGS_SUCCESS;
+}
+
+static void get_dx11_extensions_supported(ID3D11Device *device, AGSDX11ExtensionsSupported_600 *extensions)
+{
+    ID3D11VkExtDevice *ext_device;
+
+    if (FAILED(ID3D11Device_QueryInterface(device, &IID_ID3D11VkExtDevice, (void **)&ext_device)))
+    {
+        TRACE("No ID3D11VkExtDevice.\n");
+        return;
+    }
+
+    extensions->depthBoundsTest = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_DEPTH_BOUNDS);
+    extensions->uavOverlap = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_BARRIER_CONTROL);
+    extensions->UAVOverlapDeferredContexts = extensions->uavOverlap;
+
+    ID3D11VkExtDevice_Release(ext_device);
+
+    TRACE("extensions %#x.\n", *(unsigned int *)extensions);
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_CreateDevice( AGSContext* context,
+        const AGSDX11DeviceCreationParams* creation_params, const AGSDX11ExtensionParams* extension_params,
+        AGSDX11ReturnedParams* returned_params )
+{
+    ID3D11DeviceContext *device_context;
+    IDXGISwapChain *swapchain = NULL;
+    D3D_FEATURE_LEVEL feature_level;
+    ID3D11Device *device;
+    HRESULT hr;
+
+    TRACE("feature levels %u, pSwapChainDesc %p, app %s, engine %s %#x %#x.\n", creation_params->FeatureLevels,
+            creation_params->pSwapChainDesc,
+            debugstr_w(extension_params->agsDX11ExtensionParams511.pAppName),
+            debugstr_w(extension_params->agsDX11ExtensionParams511.pEngineName),
+            extension_params->agsDX11ExtensionParams511.appVersion,
+            extension_params->agsDX11ExtensionParams511.engineVersion);
+
+    if (!load_d3d11_functions())
+    {
+        ERR("Could not load d3d11.dll.\n");
+        return AGS_MISSING_D3D_DLL;
+    }
+    memset( returned_params, 0, amd_ags_info[context->version].dx11_returned_params_size );
+    if (creation_params->pSwapChainDesc)
+    {
+        hr = pD3D11CreateDeviceAndSwapChain(creation_params->pAdapter, creation_params->DriverType,
+                creation_params->Software, creation_params->Flags, creation_params->pFeatureLevels,
+                creation_params->FeatureLevels, creation_params->SDKVersion, creation_params->pSwapChainDesc,
+                &swapchain, &device, &feature_level, &device_context);
+    }
+    else
+    {
+        hr = pD3D11CreateDevice(creation_params->pAdapter, creation_params->DriverType,
+                creation_params->Software, creation_params->Flags, creation_params->pFeatureLevels,
+                creation_params->FeatureLevels, creation_params->SDKVersion,
+                &device, &feature_level, &device_context);
+    }
+    if (FAILED(hr))
+    {
+        ERR("Device creation failed, hr %#x.\n", hr);
+        return AGS_DX_FAILURE;
+    }
+
+    get_dx11_extensions_supported(device, &context->extensions);
+
+    if (context->version < AMD_AGS_VERSION_5_2_0)
+    {
+        AGSDX11ReturnedParams_511 *r = &returned_params->agsDX11ReturnedParams511;
+        r->pDevice = device;
+        r->pImmediateContext = device_context;
+        r->pSwapChain = swapchain;
+        r->FeatureLevel = feature_level;
+        r->extensionsSupported = *(unsigned int *)&context->extensions;
+    }
+    else if (context->version < AMD_AGS_VERSION_6_0_0)
+    {
+        AGSDX11ReturnedParams_520 *r = &returned_params->agsDX11ReturnedParams520;
+        r->pDevice = device;
+        r->pImmediateContext = device_context;
+        r->pSwapChain = swapchain;
+        r->FeatureLevel = feature_level;
+        r->extensionsSupported = *(unsigned int *)&context->extensions;
+    }
+    else
+    {
+        AGSDX11ReturnedParams_600 *r = &returned_params->agsDX11ReturnedParams600;
+        r->pDevice = device;
+        r->pImmediateContext = device_context;
+        r->pSwapChain = swapchain;
+        r->featureLevel = feature_level;
+        r->extensionsSupported = context->extensions;
+    }
+
+    if (context->version < AMD_AGS_VERSION_5_3_0)
+    {
+        /* Later versions pass context to functions explicitly, no need to keep it. */
+        if (context->d3d11_context)
+            ID3D11DeviceContext_Release(context->d3d11_context);
+        ID3D11DeviceContext_AddRef(device_context);
+        context->d3d11_context = device_context;
+    }
+
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX12_CreateDevice(AGSContext *context,
+        const AGSDX12DeviceCreationParams *creation_params, const AGSDX12ExtensionParams *extension_params,
+        AGSDX12ReturnedParams *returned_params)
+{
+    HRESULT hr;
+
+    TRACE("feature level %#x, app %s, engine %s %#x %#x.\n", creation_params->FeatureLevel, debugstr_w(extension_params->pAppName),
+            debugstr_w(extension_params->pEngineName), extension_params->appVersion, extension_params->engineVersion);
+
+    if (!load_d3d12_functions())
+    {
+        ERR("Could not load d3d12.dll.\n");
+        return AGS_MISSING_D3D_DLL;
+    }
+
+    memset(returned_params, 0, sizeof(*returned_params));
+    if (FAILED(hr = pD3D12CreateDevice((IUnknown *)creation_params->pAdapter, creation_params->FeatureLevel,
+            &creation_params->iid, (void **)&returned_params->pDevice)))
+    {
+        ERR("D3D12CreateDevice failed, hr %#x.\n", hr);
+        return AGS_DX_FAILURE;
+    }
+
+    TRACE("Created d3d12 device %p.\n", returned_params->pDevice);
+
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX12_DestroyDevice(AGSContext* context, ID3D12Device* device, unsigned int* device_refs)
+{
+    ULONG ref_count;
+
+    if (!device)
+        return AGS_SUCCESS;
+
+    ref_count = ID3D12Device_Release(device);
+    if (device_refs)
+        *device_refs = (unsigned int)ref_count;
+
+    return AGS_SUCCESS;
+}
+
+AGSDriverVersionResult WINAPI agsCheckDriverVersion(const char* version_reported, unsigned int version_required)
+{
+    WARN("version_reported %s, version_required %d semi-stub.\n", debugstr_a(version_reported), version_required);
+
+    return AGS_SOFTWAREVERSIONCHECK_OK;
+}
+
+int WINAPI agsGetVersionNumber(void)
+{
+    int public_version = 0;
+    enum amd_ags_version version = determine_ags_version(&public_version);
+
+    TRACE("version %s (internal %d).\n", debugstr_agsversion(public_version), version);
+
+    return public_version;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_Init( AGSContext *context, ID3D11Device *device, unsigned int uavSlot, unsigned int *extensionsSupported )
+{
+    FIXME("context %p, device %p, uavSlot %u, extensionsSupported %p stub.\n", context, device, uavSlot, extensionsSupported);
+
+    *extensionsSupported = 0;
+    if (device)
+    {
+        if (context->version < AMD_AGS_VERSION_5_3_0)
+        {
+            /* Later versions pass context to functions explicitly, no need to keep it. */
+            if (context->d3d11_context)
+            {
+                ID3D11DeviceContext_Release(context->d3d11_context);
+                context->d3d11_context = NULL;
+            }
+            ID3D11Device_GetImmediateContext(device, &context->d3d11_context);
+        }
+        get_dx11_extensions_supported(device, &context->extensions);
+        *extensionsSupported = *(unsigned int *)&context->extensions;
+    }
+
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_DeInit( AGSContext* context )
+{
+    TRACE("context %p.\n", context);
+
+    if (context->d3d11_context)
+    {
+        ID3D11DeviceContext_Release(context->d3d11_context);
+        context->d3d11_context = NULL;
+    }
+
+    return AGS_SUCCESS;
+}
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    TRACE("%p, %u, %p.\n", instance, reason, reserved);
+
+    switch (reason)
+    {
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(instance);
+            break;
+    }
+
+    return TRUE;
+}
+
+#ifdef __x86_64__
+
+static AGSReturnCode set_depth_bounds(AGSContext* context, ID3D11DeviceContext *dx_context, bool enabled,
+        float min_depth, float max_depth)
+{
+    ID3D11VkExtContext *ext_context;
+
+    if (!context->extensions.depthBoundsTest)
+        return AGS_EXTENSION_NOT_SUPPORTED;
+
+    if (FAILED(ID3D11DeviceContext_QueryInterface(dx_context, &IID_ID3D11VkExtContext, (void **)&ext_context)))
+    {
+        TRACE("No ID3D11VkExtContext.\n");
+        return AGS_EXTENSION_NOT_SUPPORTED;
+    }
+    ID3D11VkExtContext_SetDepthBoundsTest(ext_context, enabled, min_depth, max_depth);
+    ID3D11VkExtContext_Release(ext_context);
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_SetDepthBounds(AGSContext* context, bool enabled,
+        float min_depth, float max_depth )
+{
+    TRACE("context %p, enabled %d, min_depth %f, max_depth %f.\n", context, enabled, min_depth, max_depth);
+
+    if (!context || !context->d3d11_context)
+    {
+        WARN("Invalid arguments.\n");
+        return AGS_INVALID_ARGS;
+    }
+
+    return set_depth_bounds(context, context->d3d11_context, enabled, min_depth, max_depth);
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_SetDepthBounds_530(AGSContext* context,
+        ID3D11DeviceContext* dx_context, bool enabled, float min_depth, float max_depth )
+{
+    TRACE("context %p, dx_context %p, enabled %d, min_depth %f, max_depth %f.\n", context, dx_context, enabled,
+            min_depth, max_depth);
+
+    if (!context || !dx_context)
+    {
+        WARN("Invalid arguments.\n");
+        return AGS_INVALID_ARGS;
+    }
+
+    return set_depth_bounds(context, dx_context, enabled, min_depth, max_depth);
+}
+
+C_ASSERT(AMD_AGS_VERSION_5_3_0 == 3);
+__ASM_GLOBAL_FUNC( DX11_SetDepthBounds_impl,
+                   "mov (%rcx),%eax\n\t" /* version */
+                   "cmp $3,%eax\n\t"
+                   "jge 1f\n\t"
+                   "jmp " __ASM_NAME("agsDriverExtensionsDX11_SetDepthBounds") "\n\t"
+                   "1:\tjmp " __ASM_NAME("agsDriverExtensionsDX11_SetDepthBounds_530") )
+
+static AGSReturnCode update_uav_overlap(AGSContext* context, ID3D11DeviceContext *dx_context, BOOL set)
+{
+    ID3D11VkExtContext *ext_context;
+
+    if (!context->extensions.uavOverlap)
+        return AGS_EXTENSION_NOT_SUPPORTED;
+
+    if (FAILED(ID3D11DeviceContext_QueryInterface(dx_context, &IID_ID3D11VkExtContext, (void **)&ext_context)))
+    {
+        TRACE("No ID3D11VkExtContext.\n");
+        return AGS_EXTENSION_NOT_SUPPORTED;
+    }
+
+    ID3D11VkExtContext_SetBarrierControl(ext_context, set ? D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE : 0);
+    ID3D11VkExtContext_Release(ext_context);
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_BeginUAVOverlap_520(AGSContext *context)
+{
+    TRACE("context %p.\n", context);
+
+    if (!context || !context->d3d11_context)
+    {
+        WARN("Invalid arguments.\n");
+        return AGS_INVALID_ARGS;
+    }
+
+    return update_uav_overlap(context, context->d3d11_context, TRUE);
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_BeginUAVOverlap(AGSContext *context, ID3D11DeviceContext *dx_context)
+{
+    TRACE("context %p, dx_context %p.\n", context, dx_context);
+
+    if (!context || !dx_context)
+    {
+        WARN("Invalid arguments.\n");
+        return AGS_INVALID_ARGS;
+    }
+
+    return update_uav_overlap(context, dx_context, TRUE);
+}
+
+C_ASSERT(AMD_AGS_VERSION_5_3_0 == 3);
+__ASM_GLOBAL_FUNC( DX11_BeginUAVOverlap_impl,
+                   "mov (%rcx),%eax\n\t" /* version */
+                   "cmp $3,%eax\n\t"
+                   "jge 1f\n\t"
+                   "jmp " __ASM_NAME("agsDriverExtensionsDX11_BeginUAVOverlap_520") "\n\t"
+                   "1:\tjmp " __ASM_NAME("agsDriverExtensionsDX11_BeginUAVOverlap") )
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_EndUAVOverlap_520(AGSContext *context)
+{
+    TRACE("context %p.\n", context);
+
+    if (!context || !context->d3d11_context)
+    {
+        WARN("Invalid arguments.\n");
+        return AGS_INVALID_ARGS;
+    }
+
+    return update_uav_overlap(context, context->d3d11_context, FALSE);
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_EndUAVOverlap(AGSContext *context, ID3D11DeviceContext *dx_context)
+{
+    TRACE("context %p, dx_context %p.\n", context, dx_context);
+
+    if (!context || !dx_context)
+    {
+        WARN("Invalid arguments.\n");
+        return AGS_INVALID_ARGS;
+    }
+
+    return update_uav_overlap(context, dx_context, FALSE);
+}
+
+C_ASSERT(AMD_AGS_VERSION_5_3_0 == 3);
+__ASM_GLOBAL_FUNC( DX11_EndUAVOverlap_impl,
+                   "mov (%rcx),%eax\n\t" /* version */
+                   "cmp $3,%eax\n\t"
+                   "jge 1f\n\t"
+                   "jmp " __ASM_NAME("agsDriverExtensionsDX11_EndUAVOverlap_520") "\n\t"
+                   "1:\tjmp " __ASM_NAME("agsDriverExtensionsDX11_EndUAVOverlap") )
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_DestroyDevice_520(AGSContext *context, ID3D11Device* device,
+        unsigned int *device_ref, ID3D11DeviceContext *device_context,
+        unsigned int *context_ref)
+{
+    ULONG ref;
+
+    TRACE("context %p, device %p, device_ref %p, device_context %p, context_ref %p.\n",
+            context, device, device_ref, device_context, context_ref);
+
+    if (!device)
+        return AGS_SUCCESS;
+
+    if (context->d3d11_context)
+    {
+        ID3D11DeviceContext_Release(context->d3d11_context);
+        context->d3d11_context = NULL;
+    }
+
+    ref = ID3D11Device_Release(device);
+    if (device_ref)
+        *device_ref = ref;
+
+    if (!device_context)
+        return AGS_SUCCESS;
+
+    ref = ID3D11DeviceContext_Release(device_context);
+    if (context_ref)
+        *context_ref = ref;
+    return AGS_SUCCESS;
+}
+
+AGSReturnCode WINAPI agsDriverExtensionsDX11_DestroyDevice_511(AGSContext *context, ID3D11Device *device,
+        unsigned int *references )
+{
+    TRACE("context %p, device %p, references %p.\n", context, device, references);
+
+    return agsDriverExtensionsDX11_DestroyDevice_520(context, device, references, NULL, NULL);
+}
+
+C_ASSERT(AMD_AGS_VERSION_5_2_0 == 2);
+__ASM_GLOBAL_FUNC( agsDriverExtensionsDX11_DestroyDevice,
+                   "mov (%rcx),%eax\n\t" /* version */
+                   "cmp $2,%eax\n\t"
+                   "jge 1f\n\t"
+                   "jmp "     __ASM_NAME("agsDriverExtensionsDX11_DestroyDevice_511") "\n\t"
+                   "1:\tjmp " __ASM_NAME("agsDriverExtensionsDX11_DestroyDevice_520") )
+#endif
diff --git a/dlls/amd_ags_x64/dxvk_interfaces.idl b/dlls/amd_ags_x64/dxvk_interfaces.idl
new file mode 100644
index 0000000..110cdb9
--- /dev/null
+++ b/dlls/amd_ags_x64/dxvk_interfaces.idl
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/amd_ags_x64/unixlib.c b/dlls/amd_ags_x64/unixlib.c
new file mode 100644
index 0000000..7e5bc5b
--- /dev/null
+++ b/dlls/amd_ags_x64/unixlib.c
@@ -0,0 +1,277 @@
+/*
+ * Unix library for amd_ags_x64 functions
+ *
+ * Copyright 2023 Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include <xf86drm.h>
+#include <amdgpu_drm.h>
+#include <amdgpu.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "wine/debug.h"
+
+#include "unixlib.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(amd_ags);
+
+#define MAX_DEVICE_COUNT 64
+
+static unsigned int device_count;
+static struct drm_amdgpu_info_device *amd_info;
+
+static NTSTATUS init( void *args )
+{
+    drmDevicePtr devices[MAX_DEVICE_COUNT];
+    amdgpu_device_handle h;
+    uint32_t major, minor;
+    int i, count, fd, ret;
+
+    device_count = 0;
+
+    if ((count = drmGetDevices(devices, MAX_DEVICE_COUNT)) <= 0)
+    {
+        ERR("drmGetDevices failed, err %d.\n", count);
+        return STATUS_UNSUCCESSFUL;
+    }
+    TRACE("Got %d devices.\n", count);
+    for (i = 0; i < count; ++i)
+    {
+        if (!devices[i] || !devices[i]->nodes[DRM_NODE_RENDER])
+        {
+            TRACE("No render node, skipping.\n");
+            continue;
+        }
+        if ((fd = open(devices[i]->nodes[DRM_NODE_RENDER], O_RDONLY | O_CLOEXEC)) < 0)
+        {
+            ERR("Failed to open device %s, errno %d.\n", devices[i]->nodes[DRM_NODE_RENDER], errno);
+            continue;
+        }
+        if ((ret = amdgpu_device_initialize(fd, &major, &minor, &h)))
+        {
+            WARN("Failed to initialize amdgpu device bustype %d, %04x:%04x, err %d.\n", devices[i]->bustype,
+                    devices[i]->deviceinfo.pci->vendor_id, devices[i]->deviceinfo.pci->device_id, ret);
+            close(fd);
+            continue;
+        }
+        amd_info = realloc(amd_info, (device_count + 1) * sizeof(*amd_info));
+        /* amdgpu_query_info() doesn't fail on short buffer (filling in the available buffer size). So older or
+         * newer DRM version should be fine but zero init the structure to avoid random values. */
+        memset(&amd_info[device_count], 0, sizeof(*amd_info));
+        if (!(ret = amdgpu_query_info(h, AMDGPU_INFO_DEV_INFO, sizeof(*amd_info), &amd_info[device_count])))
+        {
+            TRACE("Got amdgpu info for device id %04x, family %#x, external_rev %#x, chip_rev %#x.\n",
+                    amd_info[device_count].device_id, amd_info[device_count].family, amd_info[device_count].external_rev,
+                    amd_info[device_count].chip_rev);
+            ++device_count;
+        }
+        else
+        {
+            ERR("amdgpu_query_info failed, ret %d.\n", ret);
+        }
+        amdgpu_device_deinitialize(h);
+        close(fd);
+    }
+    drmFreeDevices(devices, count);
+    return STATUS_SUCCESS;
+}
+
+#ifndef AMDGPU_VRAM_TYPE_DDR5
+#   define AMDGPU_VRAM_TYPE_DDR5  10
+#endif
+#ifndef AMDGPU_VRAM_TYPE_LPDDR4
+#   define AMDGPU_VRAM_TYPE_LPDDR4 11
+#endif
+#ifndef AMDGPU_VRAM_TYPE_LPDDR5
+#   define AMDGPU_VRAM_TYPE_LPDDR5 12
+#endif
+
+/* From Mesa source. */
+static uint32_t memory_ops_per_clock(uint32_t vram_type)
+{
+   /* Based on MemoryOpsPerClockTable from PAL. */
+   switch (vram_type) {
+   case AMDGPU_VRAM_TYPE_GDDR1:
+   case AMDGPU_VRAM_TYPE_GDDR3: /* last in low-end Evergreen */
+   case AMDGPU_VRAM_TYPE_GDDR4: /* last in R7xx, not used much */
+   case AMDGPU_VRAM_TYPE_UNKNOWN:
+   default:
+      return 0;
+   case AMDGPU_VRAM_TYPE_DDR2:
+   case AMDGPU_VRAM_TYPE_DDR3:
+   case AMDGPU_VRAM_TYPE_DDR4:
+   case AMDGPU_VRAM_TYPE_LPDDR4:
+   case AMDGPU_VRAM_TYPE_HBM: /* same for HBM2 and HBM3 */
+      return 2;
+   case AMDGPU_VRAM_TYPE_DDR5:
+   case AMDGPU_VRAM_TYPE_LPDDR5:
+   case AMDGPU_VRAM_TYPE_GDDR5: /* last in Polaris and low-end Navi14 */
+      return 4;
+   case AMDGPU_VRAM_TYPE_GDDR6:
+      return 16;
+   }
+}
+
+typedef enum AsicFamily
+{
+    AsicFamily_Unknown,                                         ///< Unknown architecture, potentially from another IHV. Check \ref AGSDeviceInfo::vendorId
+    AsicFamily_PreGCN,                                          ///< Pre GCN architecture.
+    AsicFamily_GCN1,                                            ///< AMD GCN 1 architecture: Oland, Cape Verde, Pitcairn & Tahiti.
+    AsicFamily_GCN2,                                            ///< AMD GCN 2 architecture: Hawaii & Bonaire.  This also includes APUs Kaveri and Carrizo.
+    AsicFamily_GCN3,                                            ///< AMD GCN 3 architecture: Tonga & Fiji.
+    AsicFamily_GCN4,                                            ///< AMD GCN 4 architecture: Polaris.
+    AsicFamily_Vega,                                            ///< AMD Vega architecture, including Raven Ridge (ie AMD Ryzen CPU + AMD Vega GPU).
+    AsicFamily_RDNA,                                            ///< AMD RDNA architecture
+    AsicFamily_RDNA2,                                           ///< AMD RDNA2 architecture
+    AsicFamily_RDNA3,                                           ///< AMD RDNA3 architecture
+} AsicFamily;
+
+/* Constants from Mesa source. */
+#define FAMILY_UNKNOWN 0x00
+#define FAMILY_TN      0x69 /* # 105 / Trinity APUs */
+#define FAMILY_SI      0x6E /* # 110 / Southern Islands: Tahiti, Pitcairn, CapeVerde, Oland, Hainan */
+#define FAMILY_CI      0x78 /* # 120 / Sea Islands: Bonaire, Hawaii */
+#define FAMILY_KV      0x7D /* # 125 / Kaveri APUs: Spectre, Spooky, Kalindi, Godavari */
+#define FAMILY_VI      0x82 /* # 130 / Volcanic Islands: Iceland, Tonga, Fiji */
+#define FAMILY_POLARIS 0x82 /* # 130 / Polaris: 10, 11, 12 */
+#define FAMILY_CZ      0x87 /* # 135 / Carrizo APUs: Carrizo, Stoney */
+#define FAMILY_AI      0x8D /* # 141 / Vega: 10, 20 */
+#define FAMILY_RV      0x8E /* # 142 / Raven */
+#define FAMILY_NV      0x8F /* # 143 / Navi: 10 */
+#define FAMILY_VGH     0x90 /* # 144 / Van Gogh */
+#define FAMILY_NV3     0x91 /* # 145 / Navi: 3x */
+#define FAMILY_RMB     0x92 /* # 146 / Rembrandt */
+#define FAMILY_RPL     0x95 /* # 149 / Raphael */
+#define FAMILY_GFX1103 0x94
+#define FAMILY_GFX1150 0x96
+#define FAMILY_MDN     0x97 /* # 151 / Mendocino */
+
+#define ROUND_DIV(value, div) (((value) + (div) / 2) / (div))
+
+static void fill_device_info(struct drm_amdgpu_info_device *info, struct get_device_info_params *out)
+{
+    uint32_t erev = info->external_rev;
+    uint64_t max_engine_clock_khz, max_memory_clock_khz;
+
+    out->asic_family = AsicFamily_Unknown;
+    switch (info->family)
+    {
+        case FAMILY_AI:
+        case FAMILY_RV:
+            out->asic_family = AsicFamily_Vega;
+            break;
+
+        /* Treat pre-Polaris cards as Polaris. */
+        case FAMILY_CZ:
+        case FAMILY_SI:
+        case FAMILY_CI:
+        case FAMILY_KV:
+        case FAMILY_POLARIS:
+            out->asic_family = AsicFamily_GCN4;
+            break;
+
+        case FAMILY_NV:
+            if (erev >= 0x01 && erev < 0x28)
+                out->asic_family = AsicFamily_RDNA;
+            else if (erev >= 0x28 && erev < 0x50)
+                out->asic_family = AsicFamily_RDNA2;
+            break;
+
+        case FAMILY_RMB:
+        case FAMILY_RPL:
+        case FAMILY_MDN:
+        case FAMILY_VGH:
+            out->asic_family = AsicFamily_RDNA2;
+            break;
+
+        case FAMILY_NV3:
+        case FAMILY_GFX1103:
+        case FAMILY_GFX1150:
+            out->asic_family = AsicFamily_RDNA3;
+            break;
+    }
+    TRACE("family %u, erev %#x -> asicFamily %d.\n", info->family, erev, out->asic_family);
+    if (out->asic_family == AsicFamily_Unknown && info->family != FAMILY_UNKNOWN)
+    {
+        if (info->family > FAMILY_GFX1150)
+            out->asic_family = AsicFamily_RDNA3;
+        else
+            out->asic_family = AsicFamily_GCN4;
+
+        FIXME("Unrecognized family %u, erev %#x -> defaulting to %d.\n", info->family, erev,
+                out->asic_family);
+    }
+
+    out->num_cu = info->cu_active_number;
+    out->num_wgp = out->asic_family >= AsicFamily_RDNA ? out->num_cu / 2 : 0;
+    out->num_rops = info->num_rb_pipes * 4;
+    TRACE("num_cu %d, num_wgp %d, num_rops %d.\n", out->num_cu, out->num_wgp, out->num_rops);
+    /* These numbers are zero on Vangogh, workaround that (similar to how it is currently done
+     * in Mesa src/amd/common/ac_rgp.c. */
+    if (!(max_engine_clock_khz = info->max_engine_clock))
+        max_engine_clock_khz = 1300000;
+    if (!(max_memory_clock_khz = info->max_memory_clock))
+        max_memory_clock_khz = 687000;
+    out->core_clock = ROUND_DIV(max_engine_clock_khz, 1000);
+    out->memory_clock = ROUND_DIV(max_memory_clock_khz, 1000);
+    out->memory_bandwidth = ROUND_DIV(max_memory_clock_khz * memory_ops_per_clock(info->vram_type)
+            * info->vram_bit_width / 8, 1000);
+    TRACE("core_clock %uMHz, memory_clock %uMHz, memory_bandwidth %u.\n",
+            out->core_clock, out->memory_clock, out->memory_bandwidth);
+    out->teraflops = 1e-9f * max_engine_clock_khz * info->cu_active_number * 64 * 2;
+    TRACE("teraflops %.2f.\n", out->teraflops);
+}
+
+static NTSTATUS get_device_info( void *args )
+{
+    struct get_device_info_params *params = args;
+    unsigned int i;
+
+    for (i = 0; i < device_count; ++i)
+    {
+        if (amd_info[i].device_id != params->device_id)
+            continue;
+        TRACE("device %04x found.\n", params->device_id);
+        fill_device_info(&amd_info[i], params);
+        return STATUS_SUCCESS;
+    }
+    TRACE("Device %04x not found.\n", params->device_id);
+    return STATUS_NOT_FOUND;
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    init,
+    get_device_info,
+};
diff --git a/dlls/amd_ags_x64/unixlib.h b/dlls/amd_ags_x64/unixlib.h
new file mode 100644
index 0000000..72422e1
--- /dev/null
+++ b/dlls/amd_ags_x64/unixlib.h
@@ -0,0 +1,42 @@
+/*
+ * Unix library interface
+ *
+ * Copyright 2023 Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/unixlib.h"
+
+enum amd_ags_funcs
+{
+    unix_init,
+    unix_get_device_info,
+};
+
+struct get_device_info_params
+{
+    uint32_t device_id;
+    uint32_t _pad;
+    /* Output parameters. */
+    uint32_t asic_family;
+    uint32_t num_cu;
+    uint32_t num_wgp;
+    uint32_t num_rops;
+    uint32_t core_clock;
+    uint32_t memory_clock;
+    uint32_t memory_bandwidth;
+    float teraflops;
+};
-- 
2.43.0

